[{"content":" 先介绍一下Cursor吧，Cursor 是一款基于 VS Code 的现代AI编程工具，它不仅继承了 VS Code 的强大特性，还提供了AI智能编程辅助功能，能帮助开发者更高效地完成日常开发工作。\n#TODO 首页截图\n最近用Cursor用的比较多，想给大家分享如何最低成本使用Cursor，在linux.do 论坛上找到了很多分享如何使用Cursor技巧的文章。收益匪浅，其中最著名的还是cursor-auto-free这个项目，能自动走注册流程，无限体验新手14天pro体验\n#TODO 首页付费\n每个新账号有50次慢速高级请求，这个完全足够去做一个中小型项目的demo了。还有无限制的自动补全也挺好用的\n开源地址：https://github.com/chengazhen/cursor-auto-free\n6.2k star\n我想整理一下逻辑原理流程 关闭Corsor 启动浏览器注册流程 填入邮箱，邮箱接受 CF自动邮箱前缀 转发到固定邮箱读取验证码 验证获取成功更换机器码。自动登录\n重要的是过验证码\n","date":"2025-03-11T10:34:20+08:00","image":"https://munihehacker/my-blog.github.io/p/cursor-auto-free%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/title_hu8d1d46b8a327ff77d30ebc07d12384a6_783233_120x120_fill_box_smart1_3.png","permalink":"https://munihehacker/my-blog.github.io/p/cursor-auto-free%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/","title":"Cursor Auto Free使用教程"},{"content":"\n前言 需求是编写第一个智能合约并发布到链上，只能合约就是使用solidity这个语言\n智能合约就是一段代码，solidity就是一个类似javascript 语言，描述这段智能合约。\n那么在哪里编辑这段代码呢，就是Remix\nRemix 就是专门编写智能合约的 WebIDE，注意是web IDE，可以在浏览器环境中编写智能合约。\n以太坊智能合约 上链的过程：\n编写智能合约代码： 使用 Solidity 或 Vyper 等语言编写智能合约代码。\n编译代码： 使用编译器将智能合约代码编译成 EVM 可执行的字节码。\n创建交易： 将字节码、合约部署参数以及其他必要信息打包成一个交易。\n广播交易： 将交易广播给以太坊网络中的多个节点。\n等待区块确认： 交易被包含在区块中，并被矿工验证。\n部署完成： 当交易被包含在区块中并被确认后，智能合约部署完成。\nremix 编写代码 remix 官网： https://remix.ethereum.org/\n思路：\n彩票合约代码思路 - Markdown 版本 概述:\n这是一个简单的彩票合约，允许用户参与彩票活动。合约拥有者可以设置活动持续时间，并最终结束彩票活动，选出中奖者并分配奖金。\n核心功能:\n合约初始化:\n设置合约拥有者为部署者。 定义彩票活动持续时间。 初始化彩票状态为“进行中”。 参与彩票:\n任何用户都可以参与。 参与需要至少 0.1 ETH 的费用。 检查彩票是否已经结束。 如果彩票仍在进行，将参与者地址添加到参与者列表中。 记录参与事件。 结束彩票:\n只有合约拥有者可以结束彩票活动。 检查是否已达到活动结束时间。 检查彩票是否仍在进行中。 检查参与者数量是否足够。 将彩票状态设置为“已结束”。 随机选出三位中奖者。 将奖金转账给中奖者。 记录彩票结束事件。 代码结构:\n构造函数: 初始化合约状态。 参与函数: 处理用户参与彩票活动。 结束函数: 结束彩票活动并分配奖金。 事件: 记录参与和结束事件，方便追踪彩票活动。 关键点:\n合约拥有者拥有结束彩票活动的权限。 参与者需要支付一定费用才能参与。 中奖者通过随机抽取的方式选出。 合约使用事件记录彩票活动的关键状态变化。 其他:\n可以考虑添加更多功能，例如查看参与者列表、查询中奖者等。 可以使用更安全的随机数生成方法。 可以使用更复杂的奖金分配机制。 具体代码：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 // SPDX-License-Identifier: MIT pragma solidity ^0.8.0; // 定义一个彩票合约 contract Lottery { address public owner; // 合约的拥有者 address payable[] public participants; // 参与彩票的用户数组 uint256 public lotteryEndTime; // 彩票活动的结束时间 bool public lotteryEnded; // 彩票活动是否已结束的标志 // 定义一个事件，当用户参与彩票时触发 event LotteryEnter(address indexed participant); // 定义一个事件，当彩票结束时触发，记录中奖者地址 event LotteryEnd(address winner1, address winner2, address winner3); // 构造函数，设置彩票活动的持续时间 constructor(uint _durationMinutes) { owner = msg.sender; // 设置合约拥有者为部署合约的用户 lotteryEndTime = block.timestamp + (_durationMinutes * 1 minutes); // 计算彩票活动的结束时间 lotteryEnded = false; // 初始化彩票活动未结束的标志 } // 允许用户参与彩票的函数 function enterLottery() public payable { require(msg.value == 0.1 ether, \u0026#34;Must send exactly 0.1 ETH\u0026#34;); // 要求用户支付0.1以太币 require(block.timestamp \u0026lt;= lotteryEndTime, \u0026#34;Lottery has ended\u0026#34;); // 检查彩票活动是否已结束 require(!lotteryEnded, \u0026#34;Lottery already ended\u0026#34;); // 检查彩票活动是否已标记为结束 participants.push(payable(msg.sender)); // 将用户添加到参与者数组 emit LotteryEnter(msg.sender); // 触发参与彩票的事件 } // 结束彩票活动的函数，只能由合约拥有者调用 function endLottery() public { require(msg.sender == owner, \u0026#34;Only owner can end the lottery\u0026#34;); // 只有合约拥有者可以结束彩票活动 require(block.timestamp \u0026gt;= lotteryEndTime, \u0026#34;Lottery not yet ended\u0026#34;); // 检查彩票活动是否已到结束时间 require(!lotteryEnded, \u0026#34;Lottery already ended\u0026#34;); // 检查彩票活动是否已标记为结束 require(participants.length \u0026gt;= 3, \u0026#34;Not enough participants\u0026#34;); // 检查是否有足够的参与者 lotteryEnded = true; // 标记彩票活动为已结束 uint256 prize = address(this).balance / 3; // 计算每个中奖者的奖金 // 为了避免重复中奖，我们需要一个方法来确保每个中奖者是唯一的 // 以下是一个简单的解决方案，但请注意，这并不是一个安全的随机数生成方法 // 在生产环境中，应该使用更安全的随机数生成方法，如Chainlink VRF address[3] memory winnersAddresses; // 创建一个固定大小为3的地址数组来存储中奖者地址 uint256[] memory winners = new uint256[](3); // 创建一个大小为3的数组来存储中奖者的索引 for (uint i = 0; i \u0026lt; 3; i++) { uint256 winnerIndex; bool isUnique; do { winnerIndex = random() % participants.length; // 随机选择一个参与者作为中奖者 isUnique = true; // 假设选中的参与者是唯一的 for (uint j = 0; j \u0026lt; i; j++) { if (winners[j] == winnerIndex) { isUnique = false; // 如果已经选中过，标记为不唯一 break; } } } while (!isUnique); // 如果不唯一，重新选择 winners[i] = winnerIndex; // 记录中奖者的索引 winnersAddresses[i] = participants[winnerIndex]; // 记录中奖者的地址 participants[winnerIndex].transfer(prize); // 将奖金转账给中奖者 } // 循环结束，触发彩票结束的事件 emit LotteryEnd(winnersAddresses[0], winnersAddresses[1], winnersAddresses[2]); } // 生成随机数的私有函数，用于选择中奖者 function random() private view returns (uint) { // 使用区块难度、时间戳和参与者数组作为种子生成随机数 return uint(keccak256(abi.encodePacked(block.prevrandao, block.timestamp, participants))); } } ","date":"2024-07-20T22:44:42+08:00","image":"https://munihehacker/my-blog.github.io/p/web3-solidity-%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0%E5%BD%A9%E7%A5%A8%E6%99%BA%E8%83%BD%E5%90%88%E7%BA%A6/img_1_hu24f0a009d6bcf9dee52f3d8917546c86_1012998_120x120_fill_box_smart1_3.png","permalink":"https://munihehacker/my-blog.github.io/p/web3-solidity-%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0%E5%BD%A9%E7%A5%A8%E6%99%BA%E8%83%BD%E5%90%88%E7%BA%A6/","title":"Web3 Solidity 代码实现彩票智能合约"},{"content":"\n前言 本系列教程会 从新手角度 学习web3，从以太坊合约，了解基本区块链知识 第一步骤就是使用meta-mask钱包，在测试网测试 新建以太坊钱包\n介绍mate-mask钱包 meta-mask 就是web3 最流行的钱包，本教程只介绍在浏览器上面安装meta-mask钱包。 meta-mask 钱包安装之前介绍一下基本知识。\nMetaMask 是一款流行的加密货币钱包，可让您存储、管理和使用以太坊和其他区块链上的数字资产。它就像一个数字银行账户，用于存储您的加密货币和与区块链应用程序（dApps）交互。\nMetaMask 的优势：\n易于使用：MetaMask 拥有简单的界面，即使是初学者也可以轻松使用。 安全：MetaMask 使用多种安全功能来保护您的加密货币，例如密钥管理和存储。 功能丰富：MetaMask 支持各种功能，包括代币交换、NFT 管理等。 开源：MetaMask 是开源软件，这意味着其代码经过公开审查并可供任何人检查。 MetaMask 的局限性：\n仅支持以太坊和其他兼容区块链：MetaMask 目前仅支持以太坊和其他基于 EVM 的区块链。 存在安全风险：与任何加密钱包一样，MetaMask 存在安全风险，例如黑客攻击和用户错误。\n（指与以太坊虚拟机（EVM）兼容的区块链。EVM 是以太坊区块链的核心组件，用于执行智能合约。智能合约是存储在区块链上的代码，可用于执行各种操作，例如转账、创建代币和管理数据。）\n安装meta-mask钱包 在谷歌浏览器商店或者在meta-mask 官网也可以找到安装 入口 点击安装就会出现在谷歌浏览器右上角\n自动会创建一个网页标签提示初始化 接下跟随提示创建钱包，前提是创建一个密码，这个密码只会在此设备上解锁您的 MetaMask 钱包，非常重要，在web3中安全是至关重要的一环，需要增加一些复杂度，尽量不要和其他地方的密码一致\n它通常由 12 到 24 个单词组成，这些单词是从预定义的单词列表（例如 BIP-39 词汇表）中选取的。单词的数量决定了助记词的熵值或安全强度。单词越多，熵值越高，安全性越好。\n作用就是提供了一种备份机制，以防您丢失设备或忘记密码，也可以通过助记词轻松地将钱包传输到新设备 如果了解RSA 加解密的密钥方式，可以理解成一个密钥对的私钥，公钥就是钱包的地址。\n讲解meta-mask钱包 安装完成后会直接连接以太坊区块链 刚创建的钱包当然是没有任何ETH,此时就要链接测试网，去领取一些测试用的虚拟币。\n点击左上角的选择网络，继续点击“显示测试网络“，点击Sepolia Sepolia是以太坊的 PoS（权益证明）测试网。这是一个允许开发者测试和部署去中心化应用程序（dApp）的公共区块链网络，然后再将其发布到主以太坊网络上。\n而且它是免费的测试网，因此开发人员可以随意尝试它，而无需担心任何费用。\n怎么领取测试用的ETH呢？\n为了防止滥用，多数会有条件限制，要求主网络地址内存有0.001ETH或在浏览器端挖矿来换取等等\n接下来在Sepolia 官网：https://sepolia-faucet.pk910.de/\n把刚刚创建钱包的地址复制到官网中领取测试的ETH 此时会提示钱包 不符合最低护照分数，此时提示可以使用Gitcoin Passport验证您的唯一身份并提高您的分数。\n点击链接钱包 链接钱包登录成功过后就提示可以提升自己的护照分数了，点击继续，此时提示有90天的有效期，随时可以重新认证\n此时可以验证自己的真实的虚拟币资产或者其他账号信息，这里我链接了我的gitHub 来提升自己的护照分数，这些分数再用来挖矿获取测试网的ETH 此时刷新 Sepolia 官网 再次验证 自己的公钥地址，就是在提示挖矿了，提示在每小时1.2个ETH的速度在挖矿，达到一定的数目可以定时挖矿并且索取奖励就是提现到自己的钱包中 ","date":"2024-07-20T21:47:39+08:00","image":"https://munihehacker/my-blog.github.io/p/web3-meta-mask%E9%92%B1%E5%8C%85/img_24_hu705650dd644621e4c1d5590730531160_121454_120x120_fill_box_smart1_3.png","permalink":"https://munihehacker/my-blog.github.io/p/web3-meta-mask%E9%92%B1%E5%8C%85/","title":"web3 meta-mask钱包"},{"content":"前言 今年发现一个本地使用纯前端就能实现物品识别代码，之前自己测试过yolo相关的图片检测需要配置各种驱动，环境非常麻烦，当然yolo的功能比较强大，性能也非常好，跟纯前端实现差别较大。\n具体代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34;\u0026gt; \u0026lt;meta name=\u0026#34;viewport\u0026#34; content=\u0026#34;width=device-width, initial-scale=1.0\u0026#34;\u0026gt; \u0026lt;title\u0026gt;图片识别\u0026lt;/title\u0026gt; \u0026lt;!-- CSS 样式 --\u0026gt; \u0026lt;style\u0026gt; .container { margin: 40px auto; width: max(50vw, 400px); display: flex; flex-direction: column; align-items: center; } .custom-file-upload { display: flex; align-items: center; cursor: pointer; gap: 10px; border: 2px solid black; padding: 8px 16px; border-radius: 6px; } #file-upload { display: none; } #image-container { width: 100%; margin-top: 20px; position: relative; } #image-container\u0026gt;img { width: 100%; } .bounding-box { position: absolute; box-sizing: border-box; } .bounding-box-label { position: absolute; color: white; font-size: 12px; } \u0026lt;/style\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;!-- 页面主体内容 --\u0026gt; \u0026lt;main class=\u0026#34;container\u0026#34;\u0026gt; \u0026lt;label for=\u0026#34;file-upload\u0026#34; class=\u0026#34;custom-file-upload\u0026#34;\u0026gt; \u0026lt;input type=\u0026#34;file\u0026#34; accept=\u0026#34;image/*\u0026#34; id=\u0026#34;file-upload\u0026#34;\u0026gt; 上传图片 \u0026lt;/label\u0026gt; \u0026lt;div id=\u0026#34;image-container\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;p id=\u0026#34;status\u0026#34;\u0026gt;\u0026lt;/p\u0026gt; \u0026lt;/main\u0026gt; \u0026lt;!-- JavaScript 代码 --\u0026gt; \u0026lt;script type=\u0026#34;module\u0026#34;\u0026gt; // 导入transformers nlp任务的pipeline和env对象 import { pipeline, env } from \u0026#34;https://cdn.jsdelivr.net/npm/@xenova/transformers@2.6.0\u0026#34; // 允许本地模型 env.allowLocalModels = false; // 获取文件上传和图片容器元素 const fileUpload = document.getElementById(\u0026#39;file-upload\u0026#39;); const imageContainer = document.getElementById(\u0026#39;image-container\u0026#39;) // 监听文件上传事件 fileUpload.addEventListener(\u0026#39;change\u0026#39;, function (e) { const file = e.target.files[0]; const reader = new FileReader(); reader.onload = function (e2) { const image = document.createElement(\u0026#39;img\u0026#39;); image.src = e2.target.result; imageContainer.appendChild(image) detect(image) } reader.readAsDataURL(file) }) // 获取状态信息元素 const status = document.getElementById(\u0026#39;status\u0026#39;); // 检测图片的AI任务 const detect = async (image) =\u0026gt; { status.textContent = \u0026#34;分析中...\u0026#34; const detector = await pipeline(\u0026#34;object-detection\u0026#34;, \u0026#34;Xenova/detr-resnet-50\u0026#34;) const output = await detector(image.src, { threshold: 0.1, percentage: true }) output.forEach(renderBox) } // 渲染检测框函数 function renderBox({ box, label }) { const { xmax, xmin, ymax, ymin } = box const boxElement = document.createElement(\u0026#34;div\u0026#34;); boxElement.className = \u0026#34;bounding-box\u0026#34; Object.assign(boxElement.style, { borderColor: \u0026#39;#123123\u0026#39;, borderWidth: \u0026#39;2px\u0026#39;, borderStyle: \u0026#39;solid\u0026#39;, left: 100 * xmin + \u0026#39;%\u0026#39;, top: 100 * ymin + \u0026#39;%\u0026#39;, width: 100 * (xmax - xmin) + \u0026#34;%\u0026#34;, height: 100 * (ymax - ymin) + \u0026#34;%\u0026#34; }) const labelElement = document.createElement(\u0026#39;span\u0026#39;); labelElement.textContent = label; labelElement.className = \u0026#34;bounding-box-label\u0026#34; labelElement.style.backgroundColor = \u0026#39;#000000\u0026#39; boxElement.appendChild(labelElement); imageContainer.appendChild(boxElement); } ![](https://fastly.jsdelivr.net/gh/filess/img13@main/2024/07/20/1721452050971-d50a17f8-e4ca-46f0-81bd-7c35c5917acf.png) \u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; 在本地直接使用浏览器打开这个html文件就能实现效果了\n部署 之前的文章分享过使用Vercel 部署ChatGPT网站，今天也使用Vercel 部署测试一下，非常简单，最主要是不会使用自己的任何的服务器资源，Vercel是一个云服务平台，支持静态网站和动态网站的应用部署、预览和上线，现在GitHub上面有很多主流项目都支持Vercel一键部署\n部署单文件html 实测可以忽略掉Vercel.json 这个配置文件，把上面的代码复制到新建的html文件中上传到GitHub 上，使用GitHub登录Vercel ,直接导入（import）这个项目\n然后点击部署（deploy） 不到一分钟就部署成功了，然后使用官方自带的二级域名就可以访问了 最后 Xenova/detr-resnet-50 是基于 Facebook 开发的 DETR（DEtection TRansformer）模型的改进版本，该模型在 COCO 2017 数据集上进行端到端训练，用于目标检测任务。\nXenova/detr-resnet-50 模型可以通过 Transformers.js 库在前端实现。 Transformers.js 是一个用于处理 Transformer 模型的 JavaScript 库，它提供了丰富的 API，可以方便地加载、使用和部署 Transformer 模型。\n可以在huggingface 找到Transformers.js 库的说明（https://huggingface.co/docs/transformers.js/index），还有其他很多的任务的能力，有兴趣的同学可以看看，例如：\n📝 自然语言处理：文本分类、命名实体识别、问题解答、语言建模、摘要、翻译、多项选择和文本生成。 🖼️ 计算机视觉：图像分类、物体检测和分割。 🗣️ 音频：自动语音识别和音频分类。 🐙 多模态：零样本图像分类。\n","date":"2024-07-20T13:31:01+08:00","permalink":"https://munihehacker/my-blog.github.io/p/image-recognition-functionn/","title":"Image Recognition Functionn"},{"content":"前言 最近休息了两天，在研究一些AI用于商业化方向的东西，最近找到 服装一键更换的开源项目，效果非常不错。今天就把安装步骤分享给大家，同时给大家看看真实效果。\n部署 项目地址：https://github.com/levihsu/OOTDiffusion\n没有中文的项目介绍\n首先需要拉取项目的所有代码：\n1 git clone https://github.com/levihsu/OOTDiffusion 基础环境搭建，我这里的显卡驱动已经安装好了， 有兴趣的同学可以参考我之前的本地部署ChatGLM2的文章安装显卡环境\n机器配置是 内存 32G DDR4 显卡 2070S 8G CPU 9700F 系统 Ubuntu22.04\n显卡相关的环境解决过后就需要使用conda 安装相关的依赖，现需要启动一个Python虚拟环境\n1 2 3 4 conda create -n ootd python==3.10 conda activate ootd pip install torch==2.0.1 torchvision==0.15.2 torchaudio==2.0.2 pip install -r requirements.txt 根据提示需要下载模型 ，模型下载地址有两个\n1 2 git lfs clone https://huggingface.co/levihsu/OOTDiffusion git lfs clone https://huggingface.co/openai/clip-vit-large-patch14 下载完成后移动到主项目的 checkpoints 目录，模型非常大，需要耗费很长的时间，下载完成后效果如下： 接下来需要启动web 服务，不推荐使用官方的命令行。启动web服务需要修改一下run/gradio_ootd.py,需要注销掉3行代码,默认 gradio 会调用两个显卡，目前只有一个显卡，遇到报错可以找GitHub搜一下\n1 2 3 # openpose_model_dc = OpenPose(1) # parsing_model_dc = Parsing(1) # ootd_model_dc = OOTDiffusionDC(1) 启动：\n1 python run/gradio_ootd.py 本地访问:127.0.0.1:7865: 尝试一下 把淘宝的衣服下载下来尝试了一下，效果真不错哦 还可以调整，随机种子，重绘次数，一次生成的个数参数，但是目前仅仅生成上半身，上面注释的就是注释掉全身替换的代码，需要两块显卡同时运行。目前电脑只有一张显卡只能这样了，而且对显卡的性能要求比较高运行了显存就占满了。\n最后 我觉得这个效果非常炸裂，像这样的而且有一定的商业价值的项目我觉得非常有前景，对于一些想开服装网店的创业者非常有吸引力，可以节省大量的时间和金钱成本。 今天就分享到这里，下个项目在尝试声音克隆的本地部署的开源项目，关注我\n如果感兴趣可以付费体验一下，但是只是限时七天，因为目前只是部署到我自己本地的电脑中，有点影响自己测试其他的项目。\n只须1元赞赏解锁我的部署网址，我看下付费效果，付费需求大我可以考虑部署到云服务器上给大家玩玩。并开放了一个微信群的关键字给大家讨论\n感\n","date":"2024-03-24T22:06:19+08:00","image":"https://munihehacker/my-blog.github.io/p/%E7%94%B5%E5%95%86%E5%88%A9%E5%99%A8-ootdiffusion-%E6%9C%8D%E8%A3%85%E6%9B%B4%E6%8D%A2-%E6%9C%AC%E5%9C%B0%E9%83%A8%E7%BD%B2%E6%95%88%E6%9E%9C%E9%9D%9E%E5%B8%B8%E6%A3%92/img_4_hu8fdada07a807ce18ce2ed81db3a02e90_795175_120x120_fill_box_smart1_3.png","permalink":"https://munihehacker/my-blog.github.io/p/%E7%94%B5%E5%95%86%E5%88%A9%E5%99%A8-ootdiffusion-%E6%9C%8D%E8%A3%85%E6%9B%B4%E6%8D%A2-%E6%9C%AC%E5%9C%B0%E9%83%A8%E7%BD%B2%E6%95%88%E6%9E%9C%E9%9D%9E%E5%B8%B8%E6%A3%92/","title":"电商利器 OOTDiffusion 服装更换 本地部署，效果非常棒"},{"content":"前言 前面几篇分享了一下怎么搭建私有的ChatGPT网页应用，后台收到了很多同学的私信，相信已经在使用了，今天继续分享我找到的公益ChatGPT4.0模型网页应用。\n用了很久的ChatGPT3.5模型，作为日常工作我觉得已经够用了，我个人觉得比国内的文心一言、通义千问以及讯飞星火大模型都更好用。\n个人觉得ChatGPT3.5比更强大的只有ChatGPT4.0了， ChatGPT4.0早在2023年3月15就推出来了，ChatGPT4.0 比ChatGPT3.5能更准确地理解用户输入，并生成更合理、连贯的回应，能够更好地理解上下文信息，准确捕捉用户的意图，因此产生的回答更符合语境，让用户能够更轻松地获取准确、有意义的信息。\n我自己搭建的ChatGPT3.5私有ChatGPT网页应用已经分享给很多人使用了，好多人都在问我想要合租ChatGPT4，想体验最强的‘科技’。\n目前常规手段使用ChatGPT4.0 就是通过OpenAI 官网进行付费订阅，但是对于普通来说价格来说价格还是挺贵的，\n20美元一个月，按照当前美元的汇率，一个月需要140+元人民币，个人觉得辅助工作还是没必要充值的。那怎么最低成本用到这个ChatGPT4.0\n分享 我发现了很多跟我一样ChatGPT3.5做免费站点的，我在想肯定也有人做ChatGPT4.0的免费站点的，最终花了一些时间发现在这个网站里面有很多分享：\nhttps://linux.do/ 首页 热门 菜单选项里面有很多介绍帖子 这个网站无需登录就可以访问帖子详情，我找到一个综合测评类型的帖子，找出来几个我自己常用比较稳定的网站 粘贴到这里（看到贴子升级到1级 就能看到一个精华神贴的类别，就会发现更多分享类似网站的帖子。）\nhttps://sharedchat.cn/shared.html （热度最高，人比较多，访问比较慢，稳定性还行，高度模仿官网，可以上传图片，excel等资源）\nhttp://free01.xyz/ (实时更新的分流站点，部署位置节点比较远，访问比较慢) https://chat.gking.me （界面不怎么好看，使用人比较少，访问比较慢，需要自己切换4.0）\nhttp://w10.xjai.cc （推荐，速度很快，默认就是 gpt4, 额度有限，可能会临时切回3.5）\n区分ChatGPT是3.0还是4.0 最简单的方法就是 问它 “鲁迅和周树人是一个人吗？” ChatGPT4.0会说是。ChatGPT3.5会说不是。 还有一些弱智吧的问题，ChatGPT4.0 大多数就不会落入人类的“陷阱”。 最后 我分享的一些免费使用ChatGPT4.0免费站使用人数都比较大，可能都不怎么稳定。\n写这篇文章的时候发现GitHub上面的 Coze Discord Proxy 这个项目可以利用 Coze 的机器人 API无成本搭建私有的ChatGPT4.0 网页应用，后面我想自己搭建，到时候我也会分享出来给大家使用 ，请继续关注我哦~。 往期热点： 《OpenAI Sora已开放对外申请，大家可以申请了。 》 《大模型这么火，今天手把手教大家从搭建环境开始实现本地部署ChatGLM2 6B 大模型》 《分享一下ChatGPT相关使用技巧 》 《如何搭建一个私人 ChatGPT 网页应用》\n","date":"2024-02-29T22:08:00+08:00","image":"https://munihehacker/my-blog.github.io/p/%E5%88%86%E4%BA%AB%E6%88%91%E6%90%9C%E9%9B%86%E5%88%B0%E7%9A%84chatgpt4.0%E7%9A%84%E4%B8%80%E4%BA%9B%E5%85%8D%E8%B4%B9%E7%AB%99%E7%82%B9/title_hu7f2c31cb17c6b91aa8599714a1cd3d05_95925_120x120_fill_box_smart1_3.png","permalink":"https://munihehacker/my-blog.github.io/p/%E5%88%86%E4%BA%AB%E6%88%91%E6%90%9C%E9%9B%86%E5%88%B0%E7%9A%84chatgpt4.0%E7%9A%84%E4%B8%80%E4%BA%9B%E5%85%8D%E8%B4%B9%E7%AB%99%E7%82%B9/","title":"分享我搜集到的ChatGPT4.0的一些免费站点"},{"content":"前言 Google 公司自己的大语言模型Bard 在2024年2月8号更名为 Gemini，但是Gemini 1.5 发布的时候被 OpenAI 的 Sora 抢尽了风头，堪称 AI 界的「汪峰」，听说Gemini有超长上下文的能力，支持 100 万token 的上下文，这里我还没测试，有兴趣的同学可以测试一下\n关于Gemini我就不过多介绍了，还是希望有兴趣以及有能力访问的人亲自可以直接访问试试更好（注意Gemini和OpenAI有一样的网络限制）：\nhttps://gemini.google.com/ 直接访问的使用的模型比API接口使用的模型更加聪明 还能理解图片，这可是需要付费的ChatGPT4的能力 附带Gemini的更新日志地址，详细的介绍了这个模型的特点：\nhttps://gemini.google.com/updates\n搭建 话不多说开始搭建\n获取API Key 两个月前谷歌向所有用户都免费开放了Gemini PRO大模型的API，只要你有一个谷歌账号就可以免费获取Gemini Pro大模型的API， 获取Key地址： https://aistudio.google.com/app/apikey\n私人 Gemini 网页应用采用 上篇文章说的 ChatGPT-Next-Web 这个项目，这个项目比搭建ChatGPT那个更复杂，需要增加一个.env文件\n第一步找到 https://github.com/ChatGPTNextWeb/ChatGPT-Next-Web/ 这个项目下的docker-compose.yml 文件稍作，修改为一下内容：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 version: \u0026#34;3.9\u0026#34; services: chatgpt-next-web: container_name: chatgpt-next-web image: yidadaa/chatgpt-next-web ports: - 3000:3000 environment: - OPENAI_API_KEY=$OPENAI_API_KEY - GOOGLE_API_KEY=$GOOGLE_API_KEY - CODE=$CODE - BASE_URL=$BASE_URL - OPENAI_ORG_ID=$OPENAI_ORG_ID - HIDE_USER_API_KEY=$HIDE_USER_API_KEY - DISABLE_GPT4=$DISABLE_GPT4 - ENABLE_BALANCE_QUERY=$ENABLE_BALANCE_QUERY - DISABLE_FAST_LINK=$DISABLE_FAST_LINK - OPENAI_SB=$OPENAI_SB 主要是做了一个精简，我这里不需要网络代理\n然后在项目根目录下新建一个.env文件内容如下，也是参考ChatGPT-Next-Web 官方项目根目录下的.env.template文件：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 # Your openai api key. (required) OPENAI_API_KEY= # Access passsword, separated by comma. (optional) # 设置自己想要的密码，防止滥用 CODE=*** # You can start service behind a proxy PROXY_URL=http://localhost:7890 # (optional) # Default: Empty # Googel Gemini Pro API key, set if you want to use Google Gemini Pro API. # 需要填写自己的Key GOOGLE_API_KEY=A************************F8Y # (optional) # Default: https://generativelanguage.googleapis.com/ # Googel Gemini Pro API url without pathname, set if you want to customize Google Gemini Pro API url. GOOGLE_URL= # Override openai api request base url. (optional) # Default: https://api.openai.com # Examples: http://your-openai-proxy.com BASE_URL= # Specify OpenAI organization ID.(optional) # Default: Empty OPENAI_ORG_ID= # (optional) # Default: Empty # If you do not want users to use GPT-4, set this value to 1. DISABLE_GPT4= # (optional) # Default: Empty # If you do not want users to input their own API key, set this value to 1. HIDE_USER_API_KEY= # (optional) # Default: Empty # If you do want users to query balance, set this value to 1. ENABLE_BALANCE_QUERY= # (optional) # Default: Empty # If you want to disable parse settings from url, set this value to 1. DISABLE_FAST_LINK= 只需要修改两个地方，我用中文做了提示，现在就是docker-compose 命令启动就好：\n1 docker-compose up -d 现在就可以在内网访问了,端口是3000，我这里的访问地址是：http://192.168.2.118:3000/ 提示需要密码就是我在.env文件设置的密码： 点击确认过后还需要手动选择模型，因为我这里就只填了Gemini的API Key，没有填OpenAI的Key，所以现在只能使用一个模型： 现在就可以愉快地玩耍了： 对比\u0026amp;总结 1.Gemini的相应速度比ChatGPT的要慢一些 2.Gemini的知识正确程度要比ChatGPT3.5要强一些，比ChatGPT4要弱一些，Gemini能分得清楚周树人和鲁迅是一个人，ChatGPT3.5不行 3.Gemini的代码生成能力要比ChatGPT3.5要弱些，会使用大量的英文解释，而且没有注意边界条件，我试了一下让他们生成一个斐波那契数列的Python代码观测得出的结论。 个人观点仅供参考\n最后我搭建的gemini的私有工具站点同样为了防止滥用也需要跟上篇文章一样回复关键字 gemini 来获得 上篇文章地址：《如何搭建一个私人 ChatGPT 网页应用》\n感谢大家看到最后，下次想分享一下ChatGPT4的一些白嫖站点，相信大家肯定很感兴趣，希望大家多多点赞，给个再看分享给更多的人，这是我更新的动力。\n","date":"2024-02-29T00:20:46+08:00","image":"https://munihehacker/my-blog.github.io/chat.jpg","permalink":"https://munihehacker/my-blog.github.io/p/%E8%A2%ABsora%E6%8A%A2%E5%B0%BD%E4%BA%86%E9%A3%8E%E5%A4%B4%E7%9A%84gemini%E6%80%8E%E4%B9%88%E6%A0%B7-%E4%BB%8A%E5%A4%A9%E5%88%86%E4%BA%AB%E4%B8%80%E4%B8%8B%E5%A6%82%E4%BD%95%E6%90%AD%E5%BB%BA%E4%B8%80%E4%B8%AA%E7%A7%81%E4%BA%BAgemini-%E7%BD%91%E9%A1%B5%E5%BA%94%E7%94%A8%E5%90%8C%E6%A0%B7%E5%88%86%E4%BA%AB%E7%BB%99%E5%A4%A7%E5%AE%B6%E7%8E%A9%E4%B8%80%E4%B8%8B/","title":"被Sora抢尽了风头的Gemini怎么样? 今天分享一下如何搭建一个私人Gemini 网页应用，同样分享给大家玩一下"},{"content":"前言 ChatGPT 是一个由 OpenAI 开发的大型语言模型聊天机器人，它可以生成文本、翻译语言、编写不同类型的创意内容，并以信息丰富的方式回答您的问题。\n在日常工作中也会遇到它，帮我写邮件，写前端页面，查询一些常用的代码函数功能解释，生成代码等等，非常好用，很有效地提高了我们的工作效率\n很久之前在blog 写过一个ChatGPT的教程给同事参考，有兴趣的同学们可以自己看看：https://blog.tuwei.space/p/%E8%AE%B0%E5%BD%95%E4%B8%80%E6%AC%A1chatgpt%E9%95%9C%E5%83%8F%E7%AB%99%E6%90%AD%E5%BB%BA/\n自己也部署了一个镜像站免费给一些同事朋友们用了，评价都非常不错。之前在文章 《OpenAI ChatGPT 4 悄悄免费开放了》 中也说过将会免费给大家用这个ChatGPT\n所以今天就想免费分享给更多的人用一下（也同时给自己的公众号涨点人气，只在自己公众号发这篇文章，嘿嘿）访问地址为：\nhttps://password.tuwei.space/\n为了防止滥用 设置了一个密码 ，需要扫码关注 我的微信公众号 AIGC挖掘机（pythontest） 聊天窗口回复关键字 chatgpt 才可以用\n使用技巧 使用ChatGPT需要有一点点使用技巧，这里可以分享一下我自己学到的小窍门，对于专业问题最好是通过搜索引擎或者prompt 市场找到相应的prompt提示词，这里举一个例子 ，例如最开始很火的小红书体生成器，需要找到一个最有效的prompt提示词喂给AI，它才会有效果更好的回复\n如果不填写这个prompt 提示词 它将是这样的回复\n效果非常明显，差距很大，这个工具镜像站也有自带的prompt 提示词库，可以下载下来搜索拿几个尝试一下。 其他说明 1.自己的站点使用的ChatGPT3.5的API Key，官方目前没有接口直接监控这个API Key余额的接口 2.ChatGPT API Key也有一定的速率限制（每分钟限制三次请求） 3.国内网络无法直接访问\n所以有任何报错提示麻烦各位同学及时从公众号发送消息联系我会第一时间处理并回复，看后面使用情况会优化这些问题。\n最后感谢看到最后，搭建网站不容易，大家觉得有用的话可以点个在看/赞或者分享给身边的好友。\n大家有什么其他想了解的也欢迎私信我，后面会继续分享AIGC相关，有关于我们普通人息息相关同时也能看得懂git的内容，敬请期待。\n","date":"2024-02-26T13:37:10+08:00","image":"https://munihehacker/my-blog.github.io/p/%E8%AF%B4%E5%A5%BD%E7%9A%84%E6%90%AD%E5%BB%BA%E4%B8%80%E4%B8%AAchatgpt3.5%E9%95%9C%E5%83%8F%E7%AB%99%E5%85%8D%E8%B4%B9%E5%BC%80%E5%8F%91%E7%BB%99%E5%A4%A7%E5%AE%B6%E4%BD%BF%E7%94%A8%E9%99%84%E5%B8%A6%E4%BD%BF%E7%94%A8%E6%8A%80%E5%B7%A7/chat_huebc724cc355f5f2295973454bd30997b_131368_120x120_fill_q75_box_smart1.jpg","permalink":"https://munihehacker/my-blog.github.io/p/%E8%AF%B4%E5%A5%BD%E7%9A%84%E6%90%AD%E5%BB%BA%E4%B8%80%E4%B8%AAchatgpt3.5%E9%95%9C%E5%83%8F%E7%AB%99%E5%85%8D%E8%B4%B9%E5%BC%80%E5%8F%91%E7%BB%99%E5%A4%A7%E5%AE%B6%E4%BD%BF%E7%94%A8%E9%99%84%E5%B8%A6%E4%BD%BF%E7%94%A8%E6%8A%80%E5%B7%A7/","title":"说好的搭建一个ChatGPT3.5镜像站免费开发给大家使用，附带使用技巧"},{"content":"扣子（coze.cn） 国内版已经正式上线，过去了不到一个月的时间今天来用它尝试一下做一个AI机器人。\n数据来源整理 当然是著名的V站了，找到了一个公开的爬虫项目，看到一些数据\nhttps://github.com/oldshensheep/v2ex_scrapy\n项目网站并下载releases: 下载解压： 使用Navicate 链接查看一下（无密码）： 评论表才是重要的内容 提前看了coze上传知识库的文件大小不能超过20M\n几番测试 需要筛选thank_count\u0026gt;4的内容导出的有17.4M，65193条记录\n1 SELECT content FROM \u0026#34;main\u0026#34;.\u0026#34;comment\u0026#34; WHERE \u0026#34;thank_count\u0026#34; \u0026gt; \u0026#39;4\u0026#39; coze操作 注册coze，创建Bot 添加知识库 创建知识库 新增文档 （现在回头来看是可以上传10个文件的，每个文件不超过20m），先简单试一下吧 上传之后等待自动处理完毕 报错了，分段过多 我才是一行一条数据有6w行，一个分段超过1w就不行，想了一下字符过短的语义可能分析不出来，查询的时候限制一下字符长度，thank_count调小一点，然后再分多个查询查询出多个文件看看 调整成10个查询条件如下：\n1 2 3 4 5 6 7 8 9 10 SELECT content FROM \u0026#34;main\u0026#34;.\u0026#34;comment\u0026#34; WHERE \u0026#34;thank_count\u0026#34; \u0026gt; \u0026#39;1\u0026#39; and LENGTH(content)\u0026gt;60 LIMIT 10000 OFFSET 0; SELECT content FROM \u0026#34;main\u0026#34;.\u0026#34;comment\u0026#34; WHERE \u0026#34;thank_count\u0026#34; \u0026gt; \u0026#39;1\u0026#39; and LENGTH(content)\u0026gt;60 LIMIT 10000 OFFSET 10000; SELECT content FROM \u0026#34;main\u0026#34;.\u0026#34;comment\u0026#34; WHERE \u0026#34;thank_count\u0026#34; \u0026gt; \u0026#39;1\u0026#39; and LENGTH(content)\u0026gt;60 LIMIT 10000 OFFSET 20000; SELECT content FROM \u0026#34;main\u0026#34;.\u0026#34;comment\u0026#34; WHERE \u0026#34;thank_count\u0026#34; \u0026gt; \u0026#39;1\u0026#39; and LENGTH(content)\u0026gt;60 LIMIT 10000 OFFSET 30000; SELECT content FROM \u0026#34;main\u0026#34;.\u0026#34;comment\u0026#34; WHERE \u0026#34;thank_count\u0026#34; \u0026gt; \u0026#39;1\u0026#39; and LENGTH(content)\u0026gt;60 LIMIT 10000 OFFSET 40000; SELECT content FROM \u0026#34;main\u0026#34;.\u0026#34;comment\u0026#34; WHERE \u0026#34;thank_count\u0026#34; \u0026gt; \u0026#39;1\u0026#39; and LENGTH(content)\u0026gt;60 LIMIT 10000 OFFSET 50000; SELECT content FROM \u0026#34;main\u0026#34;.\u0026#34;comment\u0026#34; WHERE \u0026#34;thank_count\u0026#34; \u0026gt; \u0026#39;1\u0026#39; and LENGTH(content)\u0026gt;60 LIMIT 10000 OFFSET 60000; SELECT content FROM \u0026#34;main\u0026#34;.\u0026#34;comment\u0026#34; WHERE \u0026#34;thank_count\u0026#34; \u0026gt; \u0026#39;1\u0026#39; and LENGTH(content)\u0026gt;60 LIMIT 10000 OFFSET 70000; SELECT content FROM \u0026#34;main\u0026#34;.\u0026#34;comment\u0026#34; WHERE \u0026#34;thank_count\u0026#34; \u0026gt; \u0026#39;1\u0026#39; and LENGTH(content)\u0026gt;60 LIMIT 10000 OFFSET 80000; SELECT content FROM \u0026#34;main\u0026#34;.\u0026#34;comment\u0026#34; WHERE \u0026#34;thank_count\u0026#34; \u0026gt; \u0026#39;1\u0026#39; and LENGTH(content)\u0026gt;60 LIMIT 10000 OFFSET 90000; 查询出的内容分成10分全部自动分段 内部报错，尝试自动自定义分段 然后全部启用 回到创建的机器人这里，点开机器人添加知识库 设置一下人设与回复逻辑：\n1 2 # 角色 你是一个功能强大的评论总结搜索助手，主要的功能就是根据知识库可以满足各种常见的问题。 最后发布 再次发布到商店 测试 感觉效果不是很好，\n尝试过导入到国外版的coze机器人里面，可以通过聊天可以直接问到一些详细具体的语料信息。\n国内外机器人都上线了 大家可以自己来试一下或者有什么意见给到我呢？ 国内版 ：BotID: 7339025335163387942 https://doubao.com/bot/rd0rttVE 国外版：https://ciciai.com/bot/sygGSrXY\n","date":"2024-02-22T10:24:57+08:00","image":"https://munihehacker/my-blog.github.io/p/%E5%AF%BC%E5%85%A5%E7%A8%8B%E5%BA%8F%E5%91%98%E8%AE%BA%E5%9D%9B%E5%B8%96%E5%AD%90%E8%AF%84%E8%AE%BA%E5%B0%9D%E8%AF%95%E7%94%A8%E6%89%A3%E5%AD%90-coze-ai-bot-%E5%BC%80%E5%8F%91%E5%B9%B3%E5%8F%B0-%E6%80%BB%E7%BB%93%E4%B8%80%E4%B8%8B/title_hu073597bf82840f8b6f778d00e82ff170_2384_120x120_fill_box_smart1_3.png","permalink":"https://munihehacker/my-blog.github.io/p/%E5%AF%BC%E5%85%A5%E7%A8%8B%E5%BA%8F%E5%91%98%E8%AE%BA%E5%9D%9B%E5%B8%96%E5%AD%90%E8%AF%84%E8%AE%BA%E5%B0%9D%E8%AF%95%E7%94%A8%E6%89%A3%E5%AD%90-coze-ai-bot-%E5%BC%80%E5%8F%91%E5%B9%B3%E5%8F%B0-%E6%80%BB%E7%BB%93%E4%B8%80%E4%B8%8B/","title":"导入程序员论坛帖子评论,尝试用扣子 coze AI Bot 开发平台 总结一下"},{"content":"前言 前几天用Stable Diffusion到做一个文字图片融合的示例，今天就使用 Stable Diffusion API 批量操作制作，使用文生图API把视频拆成一帧一帧的图片，把这些图片融入到Stable Diffusion生成的图片里面去。\n自己的Stable Diffusion 部署在Linux系统上，每次开机都需要手动切用户使用shell脚本，想做一个开机自动启动的脚本\n开机脚本 使用linux systemd 服务管理工具，我的系统版本是Ubuntu22.04，需要新建服务管理脚本，文件位置：/etc/systemd/system/webui.service,内容如下：\n1 2 3 4 5 6 7 8 9 10 [Unit] Description=Start sd-ui service After=multi-user.target [Service] User=koala9527 ExecStart=/home/koala9527/sd-ui/webui.sh --listen --enable-insecure-extension-access --api --gradio-auth root:123456 [Install] WantedBy=default.target 1.注意使用正确的用户启动这个命令 ，我这里是koala9527\n2.还要注意正确的Stable Diffusion 的启动目录，我这里使用的绝对路径，从根目录开始写的\n3.注意我这里相对比上篇文章写的启动参数增加一个--api的选项，这里是启动API服务\n使用一下命令使它重启自动启动并现在启动\n1 2 3 systemctl daemon-reload systemctl enable webui.service systemctl start webui.service 下载controlnet 上篇只下载了controlnet 扩展，这次需要安装它的模型\n模型地址：https://huggingface.co/lllyasviel/ControlNet-v1-1\n需要使用Git下载移动到相关目录：/*sd安装目录*/extensions/sd-webui-controlnet/models (体积比较大，耐心等待~)\n下载移动完成后效果： 参考源码 没有官方文档，自己找了一些案例测试了很久，最后是按照这个项目完成了想要的结果\nControlNet API项目地址： https://github.com/Mikubill/sd-webui-controlnet\nAPI 刚在脚本启动的时候增加了一个参数：--api，开放了相关的API 接口，现在访问Stable Diffusion 的地址加上/api:\n1 http://192.168.2.226:7860/docs 找到接口：sdapi/v1/txt2img 所以得到最终的请求接口：http://192.168.2.226:7860/sdapi/v1/txt2img\n根据上篇文章的图片融合的功能构造的请求参数：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 { \u0026#34;alwayson_scripts\u0026#34;: { \u0026#34;controlnet\u0026#34;: { \u0026#34;args\u0026#34;: [ { \u0026#34;enabled\u0026#34;: true, \u0026#34;model\u0026#34;: \u0026#34;control_v11f1e_sd15_tile [a371b31b]\u0026#34;, \u0026#34;module\u0026#34;: \u0026#34;tile_resample\u0026#34;, \u0026#34;weight\u0026#34;: 0.85, \u0026#34;image\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;resize_mode\u0026#34;: 0, \u0026#34;lowvram\u0026#34;: true, \u0026#34;processor_res\u0026#34;: 0, \u0026#34;threshold_a\u0026#34;: 0, \u0026#34;threshold_b\u0026#34;: 0, \u0026#34;guidance_end\u0026#34;: 0.75, \u0026#34;guidance_start\u0026#34;: 0.25, \u0026#34;pixel_perfect\u0026#34;: false, \u0026#34;control_mode\u0026#34;: 0 } ] } }, \u0026#34;batch_size\u0026#34;: 1, \u0026#34;cfg_scale\u0026#34;: 7, \u0026#34;height\u0026#34;: 512, \u0026#34;negative_prompt\u0026#34;: \u0026#34;(worst quality, low quality:1.4),lowres,(Text:1.3),(logo:1.3), normal quality, cropped, blurry, drawing, painting,signature, soft, blurry, drawing, sketch, poor quality, ugly, type, word,pixelated, low resolution, saturated, high contrast, oversharpened\u0026#34;, \u0026#34;override_settings\u0026#34;: { \u0026#34;sd_model_checkpoint\u0026#34;: \u0026#34;dreamshaper_8.safetensors [879db523c3]\u0026#34;, }, \u0026#34;clip_skip\u0026#34;: 2, \u0026#34;prompt\u0026#34;: \u0026#34;dvArchModern, 85mm, f1.8, portrait, photo realistic, hyperrealistic, orante, super detailed, intricate, dramatic, sunlight lighting, shadows, high dynamic range, house, masterpiece,best quality,(8k, RAW photo:1.2),(( ultra realistic)), modernvilla, blackandwhite, architecture, building, cloud, vivid colour, masterpiece,best quality,super detailed,realistic,photorealistic, 8k, sharp focus, a photo of a building\u0026#34;, \u0026#34;restore_faces\u0026#34;: false, \u0026#34;sampler_index\u0026#34;: \u0026#34;DPM++ SDE Karras\u0026#34;, \u0026#34;sampler_name\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;script_args\u0026#34;: [ ], \u0026#34;seed\u0026#34;: -1, \u0026#34;steps\u0026#34;: 20, \u0026#34;tiling\u0026#34;: false, \u0026#34;width\u0026#34;: 512, \u0026#34;height\u0026#34;:1024 } 封装功能Python函数 大概几个逻辑： 提前需要把视频手动拆解成图片。 然后代码功能就是把这些图片分别转base64 转入SD接口，然后请求API 得到图片base64数据存到本地\n整个Python 脚本：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 import requests import io import base64 from PIL import Image, PngImagePlugin import glob url = \u0026#34;http://192.168.2.226:7860/\u0026#34; # 封装的图片转base64,转换完成过给喂给Stable Diffusion def getbase64(path): with open(path,\u0026#39;rb\u0026#39;) as file: image_data = file.read() image_data = \u0026#39;data:image/png;base64,\u0026#39;+base64.b64encode(image_data).decode(\u0026#39;utf-8\u0026#39;) return image_data def build_img(name,image_data,save_path): payload={ \u0026#34;alwayson_scripts\u0026#34;: { \u0026#34;controlnet\u0026#34;: { \u0026#34;args\u0026#34;: [ { \u0026#34;enabled\u0026#34;: True, \u0026#34;model\u0026#34;: \u0026#34;control_v11f1e_sd15_tile [a371b31b]\u0026#34;, \u0026#34;module\u0026#34;: \u0026#34;tile_resample\u0026#34;, \u0026#34;weight\u0026#34;: 0.85, \u0026#34;image\u0026#34;: image_data, \u0026#34;resize_mode\u0026#34;: 0, \u0026#34;lowvram\u0026#34;: True, \u0026#34;processor_res\u0026#34;: 0, \u0026#34;threshold_a\u0026#34;: 0, \u0026#34;threshold_b\u0026#34;: 0, \u0026#34;guidance_end\u0026#34;: 0.75, \u0026#34;guidance_start\u0026#34;: 0.25, \u0026#34;pixel_perfect\u0026#34;: False, \u0026#34;control_mode\u0026#34;: 0 } ] } }, \u0026#34;batch_size\u0026#34;: 1, \u0026#34;cfg_scale\u0026#34;: 7, \u0026#34;height\u0026#34;: 512, \u0026#34;negative_prompt\u0026#34;: \u0026#34;(worst quality, low quality:1.4),lowres,(Text:1.3),(logo:1.3), normal quality, cropped, blurry, drawing, painting,signature, soft, blurry, drawing, sketch, poor quality, ugly, type, word,pixelated, low resolution, saturated, high contrast, oversharpened\u0026#34;, \u0026#34;override_settings\u0026#34;: { \u0026#34;sd_model_checkpoint\u0026#34;: \u0026#34;dreamshaper_8.safetensors [879db523c3]\u0026#34;, }, \u0026#34;clip_skip\u0026#34;: 2, \u0026#34;prompt\u0026#34;: \u0026#34;dvArchModern, 85mm, f1.8, portrait, photo realistic, hyperrealistic, orante, super detailed, intricate, dramatic, sunlight lighting, shadows, high dynamic range, house, masterpiece,best quality,(8k, RAW photo:1.2),(( ultra realistic)), modernvilla, blackandwhite, architecture, building, cloud, vivid colour, masterpiece,best quality,super detailed,realistic,photorealistic, 8k, sharp focus, a photo of a building\u0026#34;, \u0026#34;restore_faces\u0026#34;: False, \u0026#34;sampler_index\u0026#34;: \u0026#34;DPM++ SDE Karras\u0026#34;, \u0026#34;sampler_name\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;script_args\u0026#34;: [ ], \u0026#34;seed\u0026#34;: -1, \u0026#34;steps\u0026#34;: 20, \u0026#34;tiling\u0026#34;: False, \u0026#34;width\u0026#34;: 512, \u0026#34;height\u0026#34;:1024 } response = requests.post(url=f\u0026#39;{url}sdapi/v1/txt2img\u0026#39;, json=payload) r = response.json() res = r[\u0026#39;images\u0026#39;][0] # 请求的接口会有两个图片结果，第一个是结果，第二个是contrlnet的输入原图，刚开始这里没搞清楚，走了弯路 image = Image.open(io.BytesIO(base64.b64decode(res.split(\u0026#34;,\u0026#34;,1)[0]))) png_payload = { \u0026#34;image\u0026#34;: \u0026#34;data:image/png;base64,\u0026#34; + res } response2 = requests.post(url=f\u0026#39;{url}sdapi/v1/png-info\u0026#39;, json=png_payload) PI = PngImagePlugin.PngInfo() PI.add_text(\u0026#34;parameters\u0026#34;, response2.json().get(\u0026#34;info\u0026#34;)) image.save(\u0026#39;./\u0026#39;+save_path+\u0026#39;/output_\u0026#39;+str(name)+\u0026#39;.png\u0026#39;, pnginfo=PI) # 定义要遍历的文件路径模式 file_pattern = \u0026#34;./cxk/*.png\u0026#34; path = \u0026#39;./cxk/\u0026#39; # 遍历所有匹配指定模式的文件 count = 0 for filename in glob.glob(file_pattern): # print(filename) name= filename.split(\u0026#39;\\\\\u0026#39;)[-1] print(path+name) base64data = getbase64(path+name) save_path = \u0026#39;cxk_build\u0026#39; build_img(name,base64data,save_path) print(count) count+=1 在脚本目录下还有相关读取的文件夹，需要把融合的视频拆成一帧的文件夹为cxk ,通过融合过后保存的文件夹 需要提前新建:cxk_build 文件夹\n测试 脚本运行完毕可以看到 cxk_build 文件夹生成了很多图片，我这里的视频是59秒，拆成一帧一帧的图片一共生成接近900张图片，使用的工具是ScreenToGIF，使用2070s生成一张15秒-16秒之间，粗略计算大概接近4个小时，非常耗电，哈哈 。\n然后测试了几个发现去掉三分之一的帧数观感最好，保留每一帧的图片闪动很快看不清背景图，保留一半的图每一帧的展示时间少了看不清融入的图\n效果（为了缩小gif缩小体积，画质差了很多）： 总结 其实使用 contolnet 脚本插件 LoopbackWave（ https://github.com/FizzleDorf/Loopback-Wave-for-A1111-Webui） 以及Deforum（https://github.com/deforum-art/sd-webui-deforum） 插件可以达到比上图更好的更丝滑的视频动态转场效果，但是看起来操作比较复杂，原因是自己作为程序员更希望通过发挥自己的技能来做出一些意思的东西。 后面也会继续折腾，分享教程~\n","date":"2023-12-17T17:13:36+08:00","image":"https://munihehacker/my-blog.github.io/p/stable-diffusion-ui-%E5%BC%80%E6%9C%BA%E5%90%AF%E5%8A%A8-contronet-api%E6%8E%A5%E5%85%A5/img_3_huf593e57d38497b594f7a9c60b37f078e_1355543_120x120_fill_box_smart1_3.png","permalink":"https://munihehacker/my-blog.github.io/p/stable-diffusion-ui-%E5%BC%80%E6%9C%BA%E5%90%AF%E5%8A%A8-contronet-api%E6%8E%A5%E5%85%A5/","title":"Stable Diffusion UI 开机启动 \u0026 contronet API接入"},{"content":"前言 最近在实践大模型本地部署，前几天在本地部署了一个ChatGLM大模型，刚好环境搭好了，也支持跑Stable Diffusion，所以就安装了再尝试一下。\n原因是之前在B站上有大佬做了一个Windows电脑能一键运行的Stable Diffusion的安装包，自己也下载下来玩了一下，因为刚接触上手难度比较大，玩了一下放弃了。这两天随着SD XL 发布，看到能毫秒级地文字生成图片，还有cloudflare 有免费的服务提供，太震撼了，所以想动手做一些实际的东西出来分享一下。\n对于没有接触过的同学通俗地来说Stable Diffusion 是一个开源的图像生产+调整工具，接下来我会从怎么安装Stable Diffusion到做一个文字图片融合的示例。\n安装 首先是Stable Diffusion UI项目地址：https://github.com/AUTOMATIC1111/stable-diffusion-webui\n我自己的环境是Linux环境，通过脚本安装的形式来启动网页工具，大多数人应该是Windows 环境，通过下载安装包的形式启动网页工具，这里不会介绍每个专业关键字的具体解释，但是会以新手角度顺便会说一下我遇到的问题\n根据项目介绍下载安装脚本，执行安装脚本： 有些依赖软件我已经安装，这里我会根据官方提示下载一些相关依赖：\n1 2 3 4 sudo apt install libgl1 libglib2.0-0 wget -q https://raw.githubusercontent.com/AUTOMATIC1111/stable-diffusion-webui/master/webui.sh sh webui.sh 执行安装脚本过后运行，开始的会报一个错，我是用root 权限执行的，会报错： 需要把这个webui.sh 执行权限改为非root 用户并以非root 用户运行 ，就是这样：\n此时可以看起来没有问题了，实际上没有开放到内网机器访问，监听的是127.0.0.1 ，需要成0.0.0.0就需要给webui.sh加上参数才行，我还有一些其他的需求就是打开web ui的扩展权限和访问权限验证，就是下面这样：\n1 bash webui.sh --listen --enable-insecure-extension-access --gradio-auth root:123456 还可以增加其他参数达到相应其他的功能，可以去查找官方相关资料。\n效果： 现在就可以通过内网机器访问这个机器部署的Stable Diffusion的服务了：\n此时的webui截图是我安装一些插件的之后截图,接下来需要安装一些插件：\n首先安装一个中文插件 扩展两种安装方式，第一种就是通过内置插件安装\n没安装搜这个zh\n安装过后就翻译搜不到了，搜中文： 点击安装，这里应该也可以可以直接通过网址安装 注意要在设置里面设置重启UI才能生效 还需要装一个模型浏览工具 ：C站浏览器插件 点击安装就可以 第二种是通过网址安装： 这里我通过这个网址安装了： 1.控制网络(ControlNet插件)（https://github.com/Mikubill/sd-webui-controlnet.git） 对图片进行精细化控制，以生成更具创意和控制力的图像 文字图片融合的核心插件\n2.sd_civitai_extension\t（https://github.com/civitai/sd_civitai_extension） C 站的官方扩展，可以自动下载模型，获取模型信息，检查模型更新，自动下载缩略图的能力\n3.C站浏览器插件\t（https://github.com/BlafKing/sd-civitai-browser-plus.git）\nC站就是著名的模型库完整完整网站，跟著名的Hugging Face一样的网站，但是C站有很多不可描述的东西，被墙了\n通过网址安装就用 git 项目地址点击安装就行了\n注意：所有的插件安装完成都需要在设置里面点击 ”保存设置“ 和 “重启WebUI” 下载模型 使用C站浏览器插件 下载模型 这里推荐一个模型（下了很多模型还没来得及测试）：\nmajicMIX realistic 麦橘写实\n用于生成逼真的人物肖像底层模型\n底层模型是模型生成图像所必需的，是模型的核心部分，可以相当于说基础数据集。\n直接完成就能自动进入左上角的Stable Diffusion 模型(ckpt) 选项切换就行了\n画图 这里我使用的是 majicmixRealistic 这个底层模型 生成一个人物\n需要提示词prompt提示词，找了一些prompt社区里面的关键词\n正面提示：\n1 jk_lure_dress3,8k,(realistic:1.1), (photorealistic:1.1), (masterpiece:1.1), (best quality:1.1), RAW photo, highres, ultra detailed, High detail RAW color photo,professional photograph,masterpiece, best quality,realistic,realskin,1girl,low_key,solo,lighting,long hair ,full body, standing,classroom, beautiful detailed eyes,natural lighting,, (detailed face:1.2),extremely beautiful face, 负面：\n1 white background, simple background, (ng_deepnegative_v1_75t), (badhandv4), (worst quality:2), (low quality:2), (normal quality:2), lowres, watermark, monochrome 我这里生成的人物素材是全身的，所以宽度我设置的是512，高度是1024，批次数量测试的时候就1个，几秒一个图，调好了话就一次多生成几个图，就选择每批次4-8个。\n随机种子-1 就是完全随机，想要生成的图片一致，把相关参数分享出去让别人生成一样的图片，这个随机种子参数就不能设置成-1。\nStable Diffusion有很多采样器类型，稍微查了一下资料，是指一种指用于生成图像的算法，对图像质量，速度，艺术风格有关，我这里使用DPM++ SDE Karras，\n需要选中启用，显存小启用现存优化，然后开启预览，看下设置下面点击爆炸icon 预览是否正确\n然后最重要的是控制网络这里，需要上传一个图片到控制单元0，注意白底黑字就要选择预处理器第一个反色处理，黑底白字就可以选择最后一个仅重采样，然后点击一下预处理器和模型中间 爆炸的图片 查看预览 是否图片有正常的字显示\n这个图片可以自己在windows 电脑画图中画一个 大概流程新建图片，插入文字，调整字体和大小，裁剪，保存，图片中字体位置 代表了融入图片的大概的位置，尽量居中，控制留白位置来控制在融入图片的位置，我这里是基本占满图片的设计\n然后设置非常重要的三个参数 ，控制强度，控制介入开始时间和结束时间。这三个参数代表控制网络对图片影响\n控制强度为 1.0 控制网络对生成图像的影响最大 ，字就最明显，控制强度为 0就不会有任何影响，所以这个参数应该在0.5到0.8之间， 开始时间和结束时间就是在控制强度正常的情况下对于随机图片元素的效果的影响。控制介入时机越晚，控制网络的影响就越晚开始，生成的图像就越随机，控制结束时机越晚，控制网络的影响就越晚结束，生成的图像就越随机，相反就反之。\n这里大概三个参数分别差不多就在0.7，0.2，0.7这附近，可以根据自己的测试调整\n这里测试了几个字，字的笔画复杂度 和粗细 和控制网络参数有一定关系，需要自己反复调整： 测试 除了字，还有网上特别火的图片背景融入的例子自己也测了一下，看看效果： 效果还不错，生成的十张图片可以挑选出1到3张非常完美的图片出来，因为有一定几率会出现眼睛，手指有问题的现象，找到有几种解决方案还没来得及尝试。\nStable Diffusion 还有很多内容没有研究，实际上互联网上的真实有用案例教程还是很少的，需要自己去钻研，大模型时代的机遇和挑战已经来了。\n接下来会研究其他风格图像生成，lora模型，和API 调用方向~\n","date":"2023-12-09T13:19:05+08:00","image":"https://munihehacker/my-blog.github.io/p/stable-diffusion-ui-%E4%BB%8E%E5%AE%89%E8%A3%85%E5%88%B0%E5%AE%9E%E7%8E%B0%E6%96%87%E5%AD%97%E5%9B%BE%E7%89%87%E8%9E%8D%E5%90%88%E5%85%89%E5%BD%B1%E5%AD%97%E9%94%99%E8%A7%89%E5%9B%BE%E5%9B%BE%E7%89%87%E5%88%B6%E4%BD%9C%E8%AF%A6%E7%BB%86%E6%95%99%E7%A8%8B/title_hu5bbd3cf17cecd5bfba798574e4976910_801065_120x120_fill_box_smart1_3.png","permalink":"https://munihehacker/my-blog.github.io/p/stable-diffusion-ui-%E4%BB%8E%E5%AE%89%E8%A3%85%E5%88%B0%E5%AE%9E%E7%8E%B0%E6%96%87%E5%AD%97%E5%9B%BE%E7%89%87%E8%9E%8D%E5%90%88%E5%85%89%E5%BD%B1%E5%AD%97%E9%94%99%E8%A7%89%E5%9B%BE%E5%9B%BE%E7%89%87%E5%88%B6%E4%BD%9C%E8%AF%A6%E7%BB%86%E6%95%99%E7%A8%8B/","title":"Stable Diffusion UI 从安装到实现文字图片融合（光影字，错觉图）图片制作详细教程"},{"content":"年终总结 事件:回顾2023,展望2024.\n2023.1.7起了一个博客 blog.tuwei.space, 用来记录一些技术文章, 以及一些生活感悟.一共17篇文章\n2023 大模型元年，OpenAI 领头 第一时间体验到了ChatGPT\n","date":"2023-12-05T17:15:27+08:00","permalink":"https://munihehacker/my-blog.github.io/p/2023%E5%B9%B4%E7%BB%88%E6%80%BB%E7%BB%93/","title":"2023年终总结"},{"content":"前言 AI 实在是太火了，做一个接地气的项目玩玩吧，准备做一个能在微信聊天使用的ChatGPT 助手，先做一个简单的功能出来\n功能设计 主要功能 1.获取登录二维码 2.扫描登录 3.定时检测 4.登陆成功触发 5.查询热登录状态 6.处理消息时间 6.1处理文本回复文本 6.2处理文本回复图片\n其他功能 1.按条件处理群聊消息 2.消息记录 3.下线通知\n","date":"2023-12-05T10:33:20+08:00","permalink":"https://munihehacker/my-blog.github.io/p/gin-%E5%81%9A%E4%B8%80%E4%B8%AA%E5%BE%AE%E4%BF%A1chatgpt-%E5%8A%A9%E6%89%8B/","title":"gin 做一个微信ChatGPT 助手"},{"content":"前言 自己日常工作中几乎天天都在使用ChatGPT，觉得这些工具很大程度提升了工作效率，节约了很多时间，很牛的生产力工具，十分期待它将来演化的路程。\n自己也了解过很多的相关的知识，最近想着最近的AIGC大模型这么火，怎么不自己部署试一下试试呢？想着后面能自己做微调训练出更有意思更有价值的东西出来。\n所以把自己的主力PC 做了一个双系统，然后挑一个开源大模型本地部署 首先挑一个能运行的开源模型，选中了ChatGLM2-6B 模型 ，由清华大学开源的中英双语对话模型 。部署门槛比较低，性能也错。\n项目地址：https://github.com/THUDM/ChatGLM2-6B\n硬件环境：\nCPU：i7-9700F\n内存：DDR4 32G\n显卡：2070S 8G\n软件环境（新装）：\nUbuntu 22.04 TLS\n开始 安装环境 简要说明要安装哪些东西\n主要分为三大块： 1.英伟达显卡驱动，Linux系统默认不会安装相关显卡驱动，需要自己安装。\n2.CUDA（Compute Unified Device Architecture） ，是NVIDIA公司开发的一组编程语言扩展、库和工具，让开发者能够编写内核函数，可以在GPU上并行计算。\n3.CuDNN（CUDA Deep Neural Network library），是NVIDIA公司开发的深度学习开发者提供的加速库，帮助开发者更快实现深度神经网络训练推理过程。\n先看下自己的显卡到底有没有驱动：nvidia-smi\n报错就是没有的，刚装的系统当然没有\n再看下有没有cuda 驱动：nvcc -V 也是没有安装相关驱动，当然也没有\n那么开始安装\nNVIDIA驱动 先更新一下软件源： sudo apt-get update\n查看显卡硬件支持的驱动类型：ubuntu-drivers devices 安装一个最推荐的驱动：\n可以自动安装推荐版本： sudo ubuntu-drivers autoinstall 报错了。 修改DNS:\n1 sudo vim /etc/systemd/resolved.conf 重启服务：\n1 2 systemctl restart systemd-resolved systemctl enable systemd-resolved 又出现报错： 按照推荐apt-get update 试一下再安装 可以了，安装成功： 重启（ sudo reboot）之后再查看驱动：\n成功了，提示CUDA Version: 12.2 表示这个显卡最高可以支持CUDA12.2版本\nCUDA 先安装CUDA Toolkit 下载地址：https://developer.nvidia.com/cuda-toolkit-archive\n根据官网提示在线安装试试：\n1 2 wget https://developer.download.nvidia.com/compute/cuda/12.2.0/local_installers/cuda_12.2.0_535.54.03_linux.run sudo sh cuda_12.2.0_535.54.03_linux.run Continue 提示报错： Failed to verify gcc version. See log at /var/log/cuda-installer.log for details.\n先加忽略试试看：\n1 sudo sh cuda_12.2.0_535.54.03_linux.run --override 输入：accept 安装 CUDA相关的就行，选择Install 回车 安装完成： 还没完，需要根据提示 添加环境变量\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 =========== = Summary = =========== Driver: Not Selected Toolkit: Installed in /usr/local/cuda-12.2/ Please make sure that - PATH includes /usr/local/cuda-12.2/bin - LD_LIBRARY_PATH includes /usr/local/cuda-12.2/lib64, or, add /usr/local/cuda-12.2/lib64 to /etc/ld.so.conf and run ldconfig as root To uninstall the CUDA Toolkit, run cuda-uninstaller in /usr/local/cuda-12.2/bin ***WARNING: Incomplete installation! This installation did not install the CUDA Driver. A driver of version at least 535.00 is required for CUDA 12.2 functionality to work. To install the driver using this installer, run the following command, replacing \u0026lt;CudaInstaller\u0026gt; with the name of this run file: sudo \u0026lt;CudaInstaller\u0026gt;.run --silent --driver Logfile is /var/log/cuda-installer.log 1 vim ~/.bashrc 文件末尾添加以下几行： 退保保存 使环境变量生效：\n1 source ~/.bashrc 最后验证一下：nvcc -V\ncuDNN 接下来安装cuDNN 项目的pytorch 版本是\u0026gt;2.0 进官网看看cudnn 和cuda的版本对应关系：\nhttps://developer.nvidia.com/rdp/cudnn-archive#a-collapse742-10\nCUDA 12.2 对应的是一下几个版本的cudnn\ncudnn 官方下载地址：https://developer.nvidia.com/rdp/cudnn-archive\n这里下载需要验证NVIDIA 的账号权限，我这里是win11 用SSH链接用ftp 传了上去 直接安装：sudo dpkg -i cudnn-local-repo-ubuntu2204-8.9.5.30_1.0-1_amd64.deb 安装示例复制软件源的key:\n1 sudo cp /var/cudnn-local-repo-ubuntu2204-8.9.5.30/cudnn-local-FB167084-keyring.gpg /usr/share/keyrings/ 更新软件源： sudo apt-get update 接下来还要安装运行时库，开发者库，代码示例： 这里需要指定具体的CUDA版本和cuDNN版本，上面的CUDA和cuDNN版本分别为：12.2.0 和 8.9.5.30 所以：\n1 2 3 sudo apt-get install libcudnn8=8.9.5.30-1+cuda12.2 sudo apt-get install libcudnn8-dev=8.9.5.30-1+cuda12.2 sudo apt-get install libcudnn8-samples=8.9.5.30-1+cuda12.2 执行完成验证安装：\n1 2 3 4 cp -r /usr/src/cudnn_samples_v8/ $HOME cd $HOME/cudnn_samples_v8/mnistCUDNN make clean \u0026amp;\u0026amp; make ./mnistCUDNN make 命令时 提示 找不到命令 “make” 那么就安装 apt install make\n然后又报错：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 rm -rf *o rm -rf mnistCUDNN CUDA_VERSION is 12020 Linking agains cublasLt = true CUDA VERSION: 12020 TARGET ARCH: x86_64 HOST_ARCH: x86_64 TARGET OS: linux SMS: 50 53 60 61 62 70 72 75 80 86 87 90 g++: No such file or directory nvcc fatal : Failed to preprocess host compiler properties. \u0026gt;\u0026gt;\u0026gt; WARNING - FreeImage is not set up correctly. Please ensure FreeImage is set up correctly. \u0026lt;\u0026lt;\u0026lt; [@] /usr/local/cuda/bin/nvcc -I/usr/local/cuda/include -I/usr/local/cuda/include -IFreeImage/include -ccbin g++ -m64 -gencode arch=compute_50,code=sm_50 -gencode arch=compute_53,code=sm_53 -gencode arch=compute_60,code=sm_60 -gencode arch=compute_61,code=sm_61 -gencode arch=compute_62,code=sm_62 -gencode arch=compute_70,code=sm_70 -gencode arch=compute_72,code=sm_72 -gencode arch=compute_75,code=sm_75 -gencode arch=compute_80,code=sm_80 -gencode arch=compute_86,code=sm_86 -gencode arch=compute_87,code=sm_87 -gencode arch=compute_90,code=sm_90 -gencode arch=compute_90,code=compute_90 -o fp16_dev.o -c fp16_dev.cu [@] g++ -I/usr/local/cuda/include -I/usr/local/cuda/include -IFreeImage/include -o fp16_emu.o -c fp16_emu.cpp [@] g++ -I/usr/local/cuda/include -I/usr/local/cuda/include -IFreeImage/include -o mnistCUDNN.o -c mnistCUDNN.cpp [@] /usr/local/cuda/bin/nvcc -ccbin g++ -m64 -gencode arch=compute_50,code=sm_50 -gencode arch=compute_53,code=sm_53 -gencode arch=compute_60,code=sm_60 -gencode arch=compute_61,code=sm_61 -gencode arch=compute_62,code=sm_62 -gencode arch=compute_70,code=sm_70 -gencode arch=compute_72,code=sm_72 -gencode arch=compute_75,code=sm_75 -gencode arch=compute_80,code=sm_80 -gencode arch=compute_86,code=sm_86 -gencode arch=compute_87,code=sm_87 -gencode arch=compute_90,code=sm_90 -gencode arch=compute_90,code=compute_90 -o mnistCUDNN fp16_dev.o fp16_emu.o mnistCUDNN.o -I/usr/local/cuda/include -I/usr/local/cuda/include -IFreeImage/include -L/usr/local/cuda/lib64 -L/usr/local/cuda/lib64 -L/usr/local/cuda/lib64 -lcublasLt -LFreeImage/lib/linux/x86_64 -LFreeImage/lib/linux -lcudart -lcublas -lcudnn -lfreeimage -lstdc++ -lm 继续安装相关的软件：\n1 sudo apt-get install libfreeimage3 libfreeimage-dev 还是继续一样报错，显然没有安装g++编译库，想找到具体问题，结果在NVIDIA论坛找到的解决方案：\n1 sudo apt-get install g++ freeglut3-dev web3-meta-mask-essential libx11-dev libxmu-dev libxi-dev libglu1-mesa libglu1-mesa-dev 最后成功了！！！ 部署 下载项目 官方Git项目地址：https://github.com/THUDM/ChatGLM2-6B\n1 2 git clone https://github.com/THUDM/ChatGLM2-6B cd ChatGLM2-6B 还需要提前安装一些软件\n1 apt install python3-pip git curl 这里就不使用conda了直接安装相关依赖\n1 pip install -r requirements.txt -i https://mirrors.aliyun.com/pypi/simple/ 安装Git lfs(Large File Storage) Git 的扩展，实现大文件的版本管理支持 通过项目根目录下的.gitattributes文件指定哪些文件用专门的LFS文件服务器里，和Git仓库存储位置分开。\ngit lfs 官方指南：https://github.com/git-lfs/git-lfs/blob/main/INSTALLING.md\n1 2 curl -s https://packagecloud.io/install/repositories/github/git-lfs/script.deb.sh | sudo bash sudo apt-get install git-lfs 切换一个文件夹执行Clone大模型相关的模型：git clone https://huggingface.co/THUDM/chatglm2-6b\n卡了很久，没有进度显示，看看源代码有多大： 看下载速度带宽占用：\n1 2 sudo apt install nethogs nethogs -d 5 每秒两三M左右，13G左右，理论上差不多十分钟，实际上不止 下载完成后：cd chatglm2-6b\n命令行测试 试一下命令行启动： python3 进入交互式命令行\n1 2 3 4 5 from transformers import AutoTokenizer, AutoModel tokenizer = AutoTokenizer.from_pretrained(\u0026#34;THUDM/chatglm2-6b-int4\u0026#34;, trust_remote_code=True) model = AutoModel.from_pretrained(\u0026#34;THUDM/chatglm2-6b-int4\u0026#34;, trust_remote_code=True, device=\u0026#39;cuda\u0026#39;) response, history = model.chat(tokenizer, \u0026#34;你好\u0026#34;, history=[]) print(response) 实际上AutoModel.from_pretrained 加载模型加载了很久 然后出现了报错：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 . Make sure to double-check they do not contain any added malicious code. To avoid downloading new versions of the code file, you can pin a revision. pytorch_model.bin: 100%|█████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████| 3.92G/3.92G [18:36\u0026lt;00:00, 3.51MB/s] Traceback (most recent call last): File \u0026#34;\u0026lt;stdin\u0026gt;\u0026#34;, line 1, in \u0026lt;module\u0026gt; File \u0026#34;/usr/local/lib/python3.10/dist-packages/transformers/models/auto/auto_factory.py\u0026#34;, line 479, in from_pretrained return model_class.from_pretrained( File \u0026#34;/usr/local/lib/python3.10/dist-packages/transformers/modeling_utils.py\u0026#34;, line 2675, in from_pretrained model = cls(config, *model_args, **model_kwargs) File \u0026#34;/root/.cache/huggingface/modules/transformers_modules/THUDM/chatglm2-6b-int4/66ecaf1db3a5085714e133357ea4824b69698743/modeling_chatglm.py\u0026#34;, line 856, in __init__ self.transformer = ChatGLMModel(config, empty_init=empty_init, device=device) File \u0026#34;/root/.cache/huggingface/modules/transformers_modules/THUDM/chatglm2-6b-int4/66ecaf1db3a5085714e133357ea4824b69698743/modeling_chatglm.py\u0026#34;, line 756, in __init__ self.encoder = init_method(GLMTransformer, config, **init_kwargs) File \u0026#34;/usr/local/lib/python3.10/dist-packages/torch/nn/utils/init.py\u0026#34;, line 52, in skip_init return module_cls(*args, **kwargs).to_empty(device=final_device) File \u0026#34;/usr/local/lib/python3.10/dist-packages/torch/nn/modules/module.py\u0026#34;, line 1039, in to_empty return self._apply(lambda t: torch.empty_like(t, device=device), recurse=recurse) File \u0026#34;/usr/local/lib/python3.10/dist-packages/torch/nn/modules/module.py\u0026#34;, line 810, in _apply module._apply(fn) File \u0026#34;/usr/local/lib/python3.10/dist-packages/torch/nn/modules/module.py\u0026#34;, line 810, in _apply module._apply(fn) File \u0026#34;/usr/local/lib/python3.10/dist-packages/torch/nn/modules/module.py\u0026#34;, line 810, in _apply module._apply(fn) [Previous line repeated 1 more time] File \u0026#34;/usr/local/lib/python3.10/dist-packages/torch/nn/modules/module.py\u0026#34;, line 833, in _apply param_applied = fn(param) File \u0026#34;/usr/local/lib/python3.10/dist-packages/torch/nn/modules/module.py\u0026#34;, line 1039, in \u0026lt;lambda\u0026gt; return self._apply(lambda t: torch.empty_like(t, device=device), recurse=recurse) File \u0026#34;/usr/local/lib/python3.10/dist-packages/torch/_refs/__init__.py\u0026#34;, line 4681, in empty_like return torch.empty_permuted( torch.cuda.OutOfMemoryError: CUDA out of memory. Tried to allocate 108.00 MiB. GPU 0 has a total capacty of 7.75 GiB of which 93.25 MiB is free. Including non-PyTorch memory, this process has 6.98 GiB memory in use. Of the allocated memory 6.87 GiB is allocated by PyTorch, and 1.58 MiB is reserved by PyTorch but unallocated. If reserved but unallocated memory is large try setting max_split_size_mb to avoid fragmentation. See documentation for Memory Management and PYTORCH_CUDA_ALLOC_CONF 根据issue调整量化命令，我还以为直接改量化模型名称就行：\n把\n1 model = AutoModel.from_pretrained(\u0026#34;THUDM/chatglm2-6b-int4\u0026#34;, trust_remote_code=True, device=\u0026#39;cuda\u0026#39;) 调整成：\n1 model = AutoModel.from_pretrained(\u0026#34;THUDM/chatglm2-6b-int4\u0026#34;, trust_remote_code=True).quantize(4).cuda() 解释是:如果在 from_pretrained 里传入 device='cuda'，会把量化前的模型构建在 GPU上。 ,显卡只有8G 跑不了。\n所以现在就可以了：\n问了两个问题，显存涨了300多M: 平均一个问题涨了100M显存占用,回答内容还不错，比我想象中要聪明一点点 WEB测试 找到官方的项目地址：https://github.com/THUDM/ChatGLM2-6B\n因为我是从Hugging Face 上下载的没有web测试的代码文件\n找到web_demo2.py 根据自己的显卡显存调整一下量化等级代码：\n1 2 3 4 5 6 7 8 9 10 11 ... @st.cache_resource def get_model(): tokenizer = AutoTokenizer.from_pretrained(\u0026#34;THUDM/chatglm2-6b-int4\u0026#34;, trust_remote_code=True) model = AutoModel.from_pretrained(\u0026#34;THUDM/chatglm2-6b-int4\u0026#34;, trust_remote_code=True).quantize(4).cuda() # 多显卡支持，使用下面两行代替上面一行，将num_gpus改为你实际的显卡数量 # from utils import load_model_on_gpus # model = load_model_on_gpus(\u0026#34;THUDM/chatglm2-6b\u0026#34;, num_gpus=2) model = model.eval() return tokenizer, model ... 运行命令并访问：\n1 streamlit run web.py 大模型的生成结果的文件流 可以通过streamlit流式传输 ，不用跟命令行一样等待全部结果生成出来返回，体验非常棒~\n总结 整个环境搭建流程还算比较顺利，没有卡很久 ，然后大模型问答的结果内容比我想象中要好很多，感觉比ChatGPT3.5只差了一点点 ，主要是回复得非常快，这是在第三方的在线部署的模型是体验不到的，后面可以尝试找些数据做微调训练了~\n敬请期待~\n","date":"2023-11-23T22:18:48+08:00","image":"https://munihehacker/my-blog.github.io/p/%E4%BB%8E%E6%90%AD%E5%BB%BA%E7%8E%AF%E5%A2%83%E5%BC%80%E5%A7%8B%E6%9C%AC%E5%9C%B0%E9%83%A8%E7%BD%B2chatglm2-6b%E5%A4%A7%E6%A8%A1%E5%9E%8B/title_hu509e8fd1d5148edfe7bf43d416d577c3_38375_120x120_fill_box_smart1_3.png","permalink":"https://munihehacker/my-blog.github.io/p/%E4%BB%8E%E6%90%AD%E5%BB%BA%E7%8E%AF%E5%A2%83%E5%BC%80%E5%A7%8B%E6%9C%AC%E5%9C%B0%E9%83%A8%E7%BD%B2chatglm2-6b%E5%A4%A7%E6%A8%A1%E5%9E%8B/","title":"从搭建环境开始本地部署chatGLM2-6B大模型"},{"content":"前言 前几天商场随机买了几注大乐透彩票花了20元（机选5注，自己手动选了5注），今天发现中了5块钱，好亏啊，想写一个程序程序帮我计算辅助一下哪些数字概率大一些\n思路 获取最近100期的号码，统计一下每个数字在100期内的概率，看看是不是在100期内是不是真随机，各数字的概率差距有多大\n提示：每期中一等奖的都是1/21425712的机会。中奖纪录会很小。\n获取数据 大乐透官网：https://www.lottery.gov.cn/ 选择最近一百期，打开F12,找到任意一期其中一个数字的xpath:/html/body/div[4]/div[2]/div/div/div[1]/table/tbody/tr[1]/td[6] 然后分析一下xpath,使用Chrome 插件：xpath-helper 尝试调整一下xpath ，让插件获取到最近100期的数据：\nxpath：/html/body/div[4]/div[2]/div/div/div[1]/table/tbody/tr 把图中RESULTS (100)的内容复制出来进行处理分析处理\n处理 原数据内容为：\n1 2 3 4 5 230330406101125070904061011250709 230340709101524041207091015240412 230350714232529021107142325290211 230360113222631021001132226310210 .... 分别是 期号+中奖号码+中奖号码（有重复的中奖号码） 思路：\n1.以换行分割得到每一期的内容 2.去掉每一期内容的期数，和重复的中奖号码 3.每隔两个数字分割，得出中奖的每一个数组 4.对数字进行统计次数（前区和后区独立开，因为会重复） 编码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 import matplotlib.pyplot as plt from collections import Counter from pylab import mpl begin_all_list = [] end_all_list = [] # 读取文件 with open(\u0026#39;./100.txt\u0026#39;,\u0026#39;r\u0026#39;) as f: res = f.read() for i in res.split(\u0026#39;\\n\u0026#39;): one_data = i[5:-14] # print(i,one_data) begin,end = one_data[:10],one_data[10:] # 得到前区后区的字符串 bengin_list = [begin[i:i+2] for i in range(0, len(begin), 2)] # 前区切割成数组 end_list = [end[i:i+2] for i in range(0, len(end), 2)] # 后区切割成数组 print(i,one_data,begin,end,bengin_list,end_list) begin_all_list += bengin_list # 搜集所有的前区号码 end_all_list +=end_list # 收集所有后区号码 begin_ball = range(1,36) end_ball = range(1,13) begin_ata_dict = {} for i in begin_ball: # 遍历计算所有号码在前区号码的出现的次数 counter = begin_all_list.count(\u0026#39;%02d\u0026#39; % i) rate = round(counter/(5*100),0) begin_ata_dict[str(i)] = { \u0026#34;word\u0026#34;:counter, \u0026#34;count\u0026#34;:counter } end_data_dict = {} for i in end_ball: # 遍历计算所有号码在后区号码的出现的次数 counter = end_all_list.count(\u0026#39;%02d\u0026#39; % i) rate = round(counter/(2*100),2) end_data_dict[str(i)] = { \u0026#34;word\u0026#34;:counter, \u0026#34;count\u0026#34;:counter } print(begin_ata_dict,end_data_dict) mpl.rcParams[\u0026#34;font.sans-serif\u0026#34;] = [\u0026#34;SimHei\u0026#34;] # 设置正常显示符号 mpl.rcParams[\u0026#34;axes.unicode_minus\u0026#34;] = False count_list = [x[\u0026#39;count\u0026#39;] for x in list(begin_ata_dict.values())] plt.title(\u0026#34;前区\u0026#34;) plt.grid(ls=\u0026#34;--\u0026#34;, alpha=0.5) print(list(begin_ata_dict.values()), list(begin_ata_dict.values())) plt.bar(list(begin_ata_dict.keys()), count_list) # 画图指定X，Y轴内容 for i in range(len(count_list)): word = list(begin_ata_dict.values())[i][\u0026#39;word\u0026#39;] print(\u0026#39;wrod\u0026#39;,word,list(begin_ata_dict.keys())[i]) plt.text(list(begin_ata_dict.keys())[i], word, word, va=\u0026#34;bottom\u0026#34;, ha=\u0026#34;center\u0026#34;) # 柱状图顶部文字 plt.show() # 暂不能同时显示两张图片，取消注释后单独运行展示 # count_list = [x[\u0026#39;count\u0026#39;] for x in list(end_data_dict.values())] # plt.title(\u0026#34;后区\u0026#34;) # plt.grid(ls=\u0026#34;--\u0026#34;, alpha=0.5) # print(list(end_data_dict.values()), list(end_data_dict.values())) # plt.bar(list(end_data_dict.keys()), count_list) # for i in range(len(count_list)): # word = list(end_data_dict.values())[i][\u0026#39;word\u0026#39;] # print(\u0026#39;wrod\u0026#39;,word,list(end_data_dict.keys())[i]) # plt.text(list(end_data_dict.keys())[i], word, word, va=\u0026#34;bottom\u0026#34;, ha=\u0026#34;center\u0026#34;) # plt.show() 统计前区后区的效果： 结论\u0026amp;简单分析 看起来毫无规律，前区出现次数最大差距 22-8=16次，按理来说买热门的数字应该概率大一些。\n所以简单分析：\n前区次数的众数是13次，出现13次的号码是09，12，21，29，31，34，35这几位数\n后区次数的众数是14次，出现14次的号码是03，06这几位数\n简单分析这几个数字是100期以内出现次数最多的数字，继续接着买出现次数多的数字概率应该大一点吧\n有什么更好分析的方法呢？\n","date":"2023-11-18T22:53:50+08:00","image":"https://munihehacker/my-blog.github.io/p/python%E9%80%9A%E8%BF%87%E6%9C%80%E8%BF%91100%E6%9C%9F%E7%9A%84%E5%A4%A7%E4%B9%90%E9%80%8F%E6%95%B0%E6%8D%AE%E7%BB%9F%E8%AE%A1%E5%90%84%E4%B8%AA%E6%95%B0%E5%AD%97%E7%9A%84%E6%A6%82%E7%8E%87/title_hu2f89b48ffaeeadab39b64da2fc12e2cf_10656_120x120_fill_box_smart1_3.png","permalink":"https://munihehacker/my-blog.github.io/p/python%E9%80%9A%E8%BF%87%E6%9C%80%E8%BF%91100%E6%9C%9F%E7%9A%84%E5%A4%A7%E4%B9%90%E9%80%8F%E6%95%B0%E6%8D%AE%E7%BB%9F%E8%AE%A1%E5%90%84%E4%B8%AA%E6%95%B0%E5%AD%97%E7%9A%84%E6%A6%82%E7%8E%87/","title":"Python通过最近100期的大乐透数据统计各个数字的概率"},{"content":"前言 想用nuxt3 这个框架学习一下Vu3 写个网站来展示自己的一些折腾的项目成功 ，了解一下tailwindcss\n安装 安装tailwindCSS 安装教程：https://tailwindcss.com/docs/guides/nuxtjs 完整的跟官方一样：\n安装命令（项目名称：test-nuxt）：\n1 npx nuxi@latest init test-nuxt 然后默认选择Y Ok to proceed? (y) y\n选择pnpm 为包管理器：\n1 https://tailwindcss.com/docs/guides/nuxtjs 然后cd 到项目目录 输入pnpm run dev启动,顺便看看项目目录\n（有端口占用，默认的应该是3000，我这里是3001）\n访问127.0.0.1:3001 看看效果 有一个过度好好看啊\n看看效果： 安装tailwind 参考教程：https://tailwindcss.com/docs/guides/nuxtjs\n做一下简单解析：\npnpm安装包：\n1 pnpm install -D tailwindcss postcss autoprefixer 初始化生成配置文件：\n1 npx tailwindcss init 会自动生成tailwind.config.js 配置文件在根目录:\n然后添加一段代码到nuxt的配置文件 nuxt.config.ts 中： 改之前：\n1 2 3 4 // https://nuxt.com/docs/api/configuration/nuxt-config export default defineNuxtConfig({ devtools: { enabled: true } }) 改之后\n1 2 3 4 5 6 7 8 9 10 export default defineNuxtConfig({ devtools: { enabled: true }, postcss: { plugins: { tailwindcss: {}, autoprefixer: {}, }, }, }) postcss 是一个转换css 的工具，通过插件的形式增加,扩展css功能。这里告诉我们引入了两个插件tailwindcss,autoprefixer\nautoprefixer 是一个自动为不同浏览器添加前缀的一个插件，提高编写代码的兼容性， 例如苹果的Safari 常常需要一个-webkit-的Css前缀确保CSS 能够正常工作\n然后在自动生成的tailwind.config.js以下内容：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 /** @type {import(\u0026#39;tailwindcss\u0026#39;).Config} */ export default { content: [ \u0026#34;./components/**/*.{js,vue,ts}\u0026#34;, \u0026#34;./layouts/**/*.vue\u0026#34;, \u0026#34;./pages/**/*.vue\u0026#34;, \u0026#34;./plugins/**/*.{js,ts}\u0026#34;, \u0026#34;./app.vue\u0026#34;, \u0026#34;./error.vue\u0026#34;, ], theme: { extend: {}, }, plugins: [], } content 是其中的一个选项，指定需要处理的 CSS 文件的路径\n然后在项目根目录新建一个文件和对应的文件夹:./assets/css/main.css ,其内容为：\n1 2 3 @tailwind base; @tailwind components; @tailwind utilities; 这里指明了TailwindCSS 的基础样式，组件， 使用工具。目的是接下来把这个核心文件导入到项目中， 将来使用这些工具定义页面布局和样式\n引入方法： 根目录下nuxt.config.js 里的CSS 配置项增加：~/assets/css/main.css：\n1 2 3 4 5 6 7 8 9 10 11 // https://nuxt.com/docs/api/configuration/nuxt-config export default defineNuxtConfig({ devtools: { enabled: true }, css: [\u0026#39;~/assets/css/main.css\u0026#39;], postcss: { plugins: { tailwindcss: {}, autoprefixer: {}, }, }, }) 验证 修改根目录下的App.Vue，文件内容为：\n1 2 3 4 5 6 7 \u0026lt;template\u0026gt; \u0026lt;div\u0026gt; \u0026lt;h1 class=\u0026#34;text-3xl font-bold underline\u0026#34;\u0026gt; Hello world! \u0026lt;/h1\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; 运行pmpn run dev 访问127.0.0.1:3000查看: 定义了这个标签的三个CS 用法： 可以查询相关CSS简写的含义熟悉用法，最后孰能生巧了 tailwindCSS 多查查文档就会了~\n","date":"2023-11-03T23:15:12+08:00","image":"https://munihehacker/my-blog.github.io/p/nuxt3-%E5%90%AF%E5%8A%A8-tailwindcss-%E5%90%AF%E5%8A%A8/title_hu0ff0f5297854540926125c68a91dac25_27567_120x120_fill_box_smart1_3.png","permalink":"https://munihehacker/my-blog.github.io/p/nuxt3-%E5%90%AF%E5%8A%A8-tailwindcss-%E5%90%AF%E5%8A%A8/","title":"Nuxt3 启动 tailwindCSS 启动!!!"},{"content":"前言 Vue 3 工程化单页面应用（SPA）非常流行， 具有模块化开发、更快的渲染性能优点，今天就来学习一下Vue3工程化中路由相关的学习\nvue3路由使用 vue3 配套的路由版本是vue-route4.x\n新建一个vue3 应用：\n1 npm init vue@latest 在新建项目的时候启用了vue-route\n![](屏幕截图 2023-10-14 004555.png)\n可以看到启用了vue-route这个组件 然后看到这个如何使用vue-route的相关代码: 在vue中有两种路由模式，一个是history 模式，一个是hash 模式代码示例中默认使用的是history模式，使用了createWebHistory关键字\n其中使用import.meta.env.BASE_URL是读取环境变量文件（.env）中变量为BASE_URL的作用\n使用路由模式在SPA应用里需要修改Nginx配置文件 ，把网站解析到打包过后的静态文件目录的根目录下的index.html文件，而Hash模式会将网站的URL 携带一个#符号的哈希片段，例如：https://xxxx.com/#about。这种模式兼容行比较好，但是URL 可读性比较差，两个特性不一样使用场景不同没有使用建议优先级之分，\n实践配置路由数 1 2 3 4 5 6 7 8 9 import type { RouteRecordRaw } from \u0026#34;vue-router\u0026#34;; const routes:Array\u0026lt;RouteRecordRaw\u0026gt;=[ { path:\u0026#39;/\u0026#39;, name:\u0026#39;home\u0026#39;, component:()=\u0026gt;import{\u0026#39;@viwes/home.vue\u0026#39;}, }, ] ","date":"2023-10-12T23:52:04+08:00","image":"https://munihehacker/my-blog.github.io/p/vue3-%E5%B7%A5%E7%A8%8B%E5%8C%96-%E8%B7%AF%E7%94%B1-%E5%AD%A6%E4%B9%A0/title_hu10926b4f8cbed773a1aed12861962ad9_27587_120x120_fill_q75_box_smart1.jpg","permalink":"https://munihehacker/my-blog.github.io/p/vue3-%E5%B7%A5%E7%A8%8B%E5%8C%96-%E8%B7%AF%E7%94%B1-%E5%AD%A6%E4%B9%A0/","title":"Vue3 工程化 路由 学习"},{"content":"openai/whisper\n1 docker run -d -p 9000:9000 -e ASR_MODEL_PATH=/D/CodeProject/AIGC/openai-whisper-model onerahmet/openai-whisper-asr-webservice:latest ","date":"2023-10-09T21:58:48+08:00","permalink":"https://munihehacker/my-blog.github.io/p/openai-whisper/","title":"Openai Whisper"},{"content":"前言 ChatGPT 是目前最火热的生成式人工智能工具，由OpenAI公司研发发布，我现在每天都在用它\n上篇文章讲了如何使用ChatGPT的使用技巧还给大家免费分享我自己搭建的ChatGPT网页应用《分享一下ChatGPT相关使用技巧》，有空的同学可以点击文章标题链接可以看一下。\n今天就来简单分享一下怎么安装它的镜像站。\n普通人可以直接使用我的搭建的私有ChatGPT网页应用，有兴趣的同学可以跟着我的教程来学着搭建一下。（有一定的门槛）\n必要条件 拥有一个可以访问ChatGPT 官网的和GitHub的网络环境，ChatGPT 官网地址：https://openai.com/ 购买一个ChatGPT的Key，推荐一个购买地址（0.6元人名币5刀余额的API KEY，不想买自己要用想办法用其他国家的手机号注册）：https://gpt888.shop/ (发卡网站不稳定有一定时效性) 一台可以使用Docker的机器，最好有个域名，可以公网访问更佳~ 镜私有ChatGPT网页应用推荐 下面两个开源的私有ChatGPT网页应用自己都有实践搭建过，并且市面上大多数公开分享项目都来自于这两个项目。\n1.https://github.com/Yidadaa/ChatGPT-Next-Web\n前端比较好看，交互体验非常好，感觉体验比官网还好，而且自带提示词，自带prompt提示词仓库，点击就可以使用，功能比较强大，最新版已支持Google 的 Gemini AI机器人。\n最早主分支在2023年3月7日首次提交，截止到目前24年2月28日为止已有62.3k star。\n效果： 2.https://github.com/Chanzhaoyu/chatgpt-web\n页面比较简单，实用，便捷快捷。自己一直在用，出的时候比较早。 最早主分支在2023年2月9日首次提，交截止到目前24年2月28日为止已有29.6k star。\n效果： 搭建教程 搭建非常简单，知道会使用docker,使用docker-compose容器编排工具一键搭建，以第二个镜像站为例新建一个docker-compose.yaml文件：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 version: \u0026#39;3\u0026#39; services: app: container_name: chatgpt-web image: chenzhaoyu94/chatgpt-web # 总是使用latest,更新时重新pull该tag镜像即可 restart: always ports: - 3002:3002 environment: # 二选一 OPENAI_API_KEY: sk-*************************** # 购买的key # 反向代理，可选 #API_REVERSE_PROXY: https://gpt.pawan.krd/backend-api/conversation # 网络环境不支持访问OpenAI 的时候可以使用第三方的网络代理或者自建代理 # 超时，单位毫秒，可选 TIMEOUT_MS: 120000 然后执行命令：\n1 docker-compose up -d 命令执行完毕后服务器就会自动拉取chenzhaoyu94/chatgpt-web镜像，然后在本地启动一个服务，宿主机端口为3002 我这里是用内网机器部署的，内网访问：http://192.168.2.129:3002（第一次访问加载比较慢）:\n可以直接访问了\n搭建完毕 搭建非常简单，基础，主要难点在于网络环境的搭建，需要正常访问OpenAI，还有一个合理便宜的Key的购买渠道。然后后期怎么使用域名解析这个服务能随时随地访问。这里就不做详细介绍了，每个人的情况不一样。\n我自己对这个chatgpt-web项目做了一点修改，需要提示验证码密码的时候我加了一个我自己的微信公共号二维码，替换了原项目中的Icon，然后更改了一下提示，提示需要回复关键字获取ChatGPT网页应用和密码，如果有需要可以私聊我，我会把修改过后的源码无偿提供给大家。\n感谢大家看到这里，下篇会研究一下Google公司最近推出的Gemma模型 ，看看它跟ChatGPT有多大差别， 之前用过他们的borad，这个也是跟ChatGPT一样，现在已经开发免费使用，效果也非常不错，只是没有ChatGPT名气大。\nOpenAI 公司的视频生成大模型Sora现在已开放对外申请，感兴趣也可以访问我的历史文章git：《OpenAI Sora已开放对外申请，大家可以申请了。》申请一下\n","date":"2023-09-04T22:50:54+08:00","image":"https://munihehacker/my-blog.github.io/p/%E8%AE%B0%E5%BD%95%E4%B8%80%E6%AC%A1chatgpt%E7%A7%81%E6%9C%89chatgpt%E7%BD%91%E9%A1%B5%E5%BA%94%E7%94%A8%E6%90%AD%E5%BB%BA%E6%95%99%E7%A8%8B/title_hu62cab933b2e5501d4229b78516907a97_121004_120x120_fill_q75_box_smart1.jpeg","permalink":"https://munihehacker/my-blog.github.io/p/%E8%AE%B0%E5%BD%95%E4%B8%80%E6%AC%A1chatgpt%E7%A7%81%E6%9C%89chatgpt%E7%BD%91%E9%A1%B5%E5%BA%94%E7%94%A8%E6%90%AD%E5%BB%BA%E6%95%99%E7%A8%8B/","title":"记录一次ChatGPT私有ChatGPT网页应用搭建教程"},{"content":"原因 想学UniApp不想用Vue2 ,想学习Vue3 ,但是前端必须是学习typeScript，Vue3 是用TypeScript重构的。\nTypeScript 是JavaScript 的超集。\n本篇文章只会作为快查手册，尽量减少废话。\n变量定义 引用类型 TypeScript 主要是要做数据类型的约束，避免出BUG 变量后面加上冒号加上类型：\n1 2 3 4 5 6 7 8 // 字符串 const str: string = \u0026#39;Hello World\u0026#39; // 数值 const num: number = 1 // 布尔值 const bool: boolean = true ts 也会自动推到原始数据类型，所以上面的例子也可以省略：\n1 2 3 const str = \u0026#39;Hello World\u0026#39; const num = 1 const bool = true 原始数据类型 是一种既非对象也无内置方法的数据.\n原始数据类型：\n原始数据类型 JavaScript TypeScript 字符串 String string 数值 Number number 布尔值 Boolean boolean 大整数 BigInt bigint 符号 Symbol symbol 不存在 Null null 未定义 Undefined undefined 布尔值，大整数，符号 还是很少见的\n引用类型 主要是要注意引用类型，数组 举几个例子：\n1 2 3 4 5 6 7 8 // 字符串数组 const strs: string[] = [\u0026#39;Hello World\u0026#39;, \u0026#39;Hi World\u0026#39;] // 数值数组 const nums: number[] = [1, 2, 3] // 布尔值数组 const bools: boolean[] = [true, true, false] 数组也会自动推导：\n1 2 3 const strs = [\u0026#39;Hello World\u0026#39;, \u0026#39;Hi World\u0026#39;] const nums = [1, 2, 3] const bools = [true, true, false] 需要数组里的元素有值 也可以这样:\n1 2 3 const nums: number[] = [1, 2, 3] // 如果是空的就必须要指定数组的元素类型 对象 对象的类型定义有两个语法： type 和 interface 定义对象：\n1 2 3 4 5 type Data = { name: string, age: number, } 1 2 3 4 interface Data { name: string, age: number, } interface 是比较常用的，也叫接口，通畅使用大驼峰写法（每个单词首字母大写），普通变量使用小驼峰（除了第一个单词首字母小写，其他每个单词都是大写） 声明对象，\n1 2 3 4 const myData: Data = { name: \u0026#39;aha\u0026#39;, age: 18, } 可选属性 上面在接口定义元素时每个元素都是必须的，声明时不给某个元素赋值会报错，此时就有一个可选属性的方法：\n1 2 3 4 5 6 7 8 9 interface Data { name: string, age?: number, } const myData: Data = { name: \u0026#39;aha\u0026#39;, } console.log(myData) 调用自身接口 举个例子：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 interface Data { name: string // 这个属性引用了本身的类型 list: Data[] } const myData: Data = { name: \u0026#39;Boss\u0026#39;, list: [ { \u0026#39;name\u0026#39;: \u0026#39;A\u0026#39;, list: [], }, { \u0026#39;name\u0026#39;: \u0026#39;B\u0026#39;, list: [], } ] } 接口的继承 类似于类的继承，继承父接口的所有属性，并进行追加属性\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 interface Data { name: string, age: number, } interface TestData extends Data { isTrue: Boolean } const myData: TestData = { name: \u0026#39;蓝色妖姬\u0026#39;, age: 80, isTrue: true } console.log(myData) // { name: \u0026#39;蓝色妖姬\u0026#39;, age: 80, isTrue: true } 如果不需要父接口的属性可以使用Omit 来去除父接口其中的属性 (如果有多个属性，用 | 来分隔开)\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 interface Data { name: string, age: number, say: string } interface TestData extends Omit\u0026lt;Data, \u0026#39;age\u0026#39; | \u0026#39;say\u0026#39;\u0026gt; { isTrue: Boolean } const myData: TestData = { name: \u0026#39;切尔西\u0026#39;, isTrue: true } console.log(myData) // { name: \u0026#39;切尔西\u0026#39;, isTrue: true } 类 对javascript 的类没有印象和的可以参考阮一峰的教程： Class 的基本语法\n跟其他的语言的类的用法基本一致\n通过class关键字，可以定义类\n一般用类定义内置方法,内置变量来使用类，其中constructor() 是类的构造方法（就是实例化类之后自动执行的方法）\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 // 类的定义也是大驼峰 class MyClass { constructor(name: string) { this.name = name console.log(name, \u0026#39;类被初始化！~\u0026#39;) } name: string say(data: string) { console.log(\u0026#39;我是\u0026#39;, this.name, \u0026#39;,我要说:\u0026#39;, data) } } const newClass = new MyClass(\u0026#39;test\u0026#39;); newClass.say(\u0026#39;牛逼\u0026#39;) // 打印结果： // test 类被初始化！~ // 我是 test ,我要说: 牛逼 在Vue2中常见的this ，一般也是代表某个类，也就是当前组件实例。组件实例有很多属性和方法，例如：\nthis.data是一个指向组件数据对象的引用，它包含了组件实例中定义的所有响应式数据。 this.$props: 一个对象，包含当前组件接收的所有 props。可以通过this.$props.propName来访问父组件传递过来的 prop 值。 this.$emit(event, payload): 触发当前组件上的自定义事件。可以使用该方法向父组件发送消息或触发其他组件监听的事件。 this.$refs: 一个对象，包含通过 ref 注册的所有子组件或 DOM 元素的引用。可以使用this.$refs.refName来访问子组件或 DOM 元素。 this.$watch(expressionOrFn, callback, [options]): 监听数据变化并触发回调函数。可以用于监听响应式数据或计算属性的变化。 this.$nextTick(callback): 在下次 DOM 更新循环结束之后执行回调函数。当需要在更新后执行一些操作时，可以使用该方法。 this.$router: 可以访问 Vue Router 的实例，用于进行路由导航操作。 this.$route: 当前路由信息的对象，包含当前路径、参数等信息。 this.$store: Vuex 状态管理库的实例，用于访问全局状态和派发/提交 mutations 和 actions。 类的继承 最常见的一种使用发放，类的继承示例：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 // 这是一个基础类 class Base { name: string constructor(userName: string) { this.name = userName } } // 这是另外一个类，继承自基类 class Say extends Base { sayName() { console.log(\u0026#39;我的名字是：\u0026#39;, this.name) } } // 这个变量拥有上面两个类的所有属性和方法 const testName: Say = new Say(\u0026#39;Honda\u0026#39;) testName.sayName() // 我的名字是： Honda 类的静态方法\u0026amp;静态属性 静态方法就是可以不用实例化可以直接调用类的静态方法和属性，常用于一些工具函数，不依赖于类的实例状态\n1 2 3 4 5 6 7 8 9 10 class TestClass { static myAge: number = 18 static say() { console.log(\u0026#39;牛逼666\u0026#39;) } } TestClass.say() // 牛逼666 console.log(TestClass.myAge) // 18 必须保证子类在父类之后定义。\n继承的时候必须在前面定义父类，后面写子类，不然会报错 类的方法内部如果含有this，它默认指向类的实例 箭头函数内部的this总是指向定义时所在的对象（箭头函数相当于匿名函数，并简化了函数定义，箭头函数没有原型prototype，因此箭头函数没有this指向，如果箭头函数的外层是一个普通函数，在定义的时候会继承它的this） 有些复杂的东西记录一下，后面遇到真实开发问题再填坑\n接口继承类 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 class Person { name: string; constructor(name: string) { this.name = name; } sayHello() { console.log(`Hello, I\u0026#39;m ${this.name}`); } } interface IPerson extends Person { } const person: IPerson = new Person(\u0026#34;John\u0026#34;); person.sayHello(); // Hello, I\u0026#39;m John 联合类型 大多数是指一个方法接受参数的时候可以接受多种数据类型，例如：\n1 2 3 4 5 6 function say(word: number | string) { console.log(`say: ${word}.`) } say(888) // say: 888. say(\u0026#39;北京申奥成功了！\u0026#39;) // say: 北京申奥成功了！. 函数 函数非常重要，在TypeScript 有多种写法：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 // 函数声明，最基础用法 function add1(sum1: number, sum2: number): number { return sum1 + sum2 } // 函数表达式，新手觉得难以理解的方法 const add2 = function (sum1: number, sum2: number): number { return sum1 + sum2 } // 箭头函数，新手觉得更难以理解的方法 const add3 = (sum1: number, sum2: number): number =\u0026gt; sum1 + sum2 // 对象里的方法 const obj = { add4(sum1: number, sum2: number): number { return sum1 + sum2 } } //... 无返回值的函数返回值使用void代替。 void 和 null 、 undefined 不可以混用，如果的函数返回值类型是 null ，那么是真的需要 return 一个 null 值。\n函数直接使用return 返回,没有任何内容函数指定的返回值可以用void\n可选参数 入参的时候是可选的：\n1 2 3 4 function add5(sum1: number, sum2: number, isAdd?: boolean): number { return isAdd ? x + y : x - y } 异步函数 异步函数这里有个非常重要的概念 异步函数的返回值需要用到Promise 类型来定义它的返回值：\n1 2 3 4 5 6 7 8 9 10 11 function queryData(): Promise\u0026lt;string\u0026gt; { return new Promise((resolve) =\u0026gt; { setTimeout(() =\u0026gt; { resolve(\u0026#39;Hello World\u0026#39;) }, 3000) }) } queryData().then((data) =\u0026gt; console.log(data)) // resolve指定返回的类型，如果没有resolve那么就要指定 Promise\u0026lt;void\u0026gt; 函数本身的类型 上面的匿名函数就没有类型，也就是箭头函数：\n1 2 const add = (num1: number, num2: number): number =\u0026gt; x + y // 左边只指定了add这个变量但是没有类型，原因是因为函数体会自动推导 任意值 TypeScript 也叫AnyScript，有很多不会写强类型语言的新手喜欢使用any 来表示函数的返回值或者入参，开发中应尽量避免使用\nany 是一切类型的父类型，也是一切类型的子类型\n1 2 3 function say(msg: any) { console.log(String(msg)) } 遇到其他问题我们扩展讲讲，展示就只展示一个简单的例子\n例外情况 很多npm 包都符合TypeScript 类型，但是有些个别的没有符合，把npm 包放在.ts文件运行就会报错，需要找到TypeScript 支持的特定的npm 包才可以。\ntsconfig.json 安装：\n1 npm install -g typescript 初始化项目：\n1 tsc --init 1 2 3 4 5 6 7 8 9 10 11 Created a new tsconfig.json with: TS target: es2016 module: commonjs strict: true esModuleInterop: true skipLibCheck: true forceConsistentCasingInFileNames: true You can learn more at https://aka.ms/tsconfig.json 目录接口：\n1 2 3 4 5 6 7 8 9 10 11 12 13 hello-node │ # 构建产物 ├─dist │ # 依赖文件夹 ├─node_modules │ # 源码文件夹 ├─src │ # 锁定安装依赖的版本号 ├─package-lock.json │ # 项目清单 ├─package.json │ # TypeScript 配置 └─tsconfig.json tsconfig.json：\n1 2 3 4 5 6 7 { \u0026#34;compilerOptions\u0026#34;: { \u0026#34;target\u0026#34;: \u0026#34;es6\u0026#34;, \u0026#34;module\u0026#34;: \u0026#34;es6\u0026#34;, \u0026#34;outDir\u0026#34;: \u0026#34;./dist\u0026#34; } } 完整选项和功能参考官网：tsconfig - typescriptlang 但是现在项目初始化都是使用vue-cli来新建，需要参考其他文档\n未完待续。。。\n","date":"2023-07-05T21:57:05+08:00","image":"https://munihehacker/my-blog.github.io/p/typescript%E8%AF%AD%E6%B3%95%E7%AE%80%E8%A6%81%E6%80%BB%E7%BB%93/typescript-logo_hud7a85cc4aefb053722349bc639a0a050_127301_120x120_fill_box_smart1_3.png","permalink":"https://munihehacker/my-blog.github.io/p/typescript%E8%AF%AD%E6%B3%95%E7%AE%80%E8%A6%81%E6%80%BB%E7%BB%93/","title":"TypeScript语法简要总结"},{"content":"参考教程： VUE 官网\nVue3 入门指南与实战案例\nBiliBili-尚硅谷Vue2.0+Vue3.0全套教程丨vuejs从入门到精通\n前言 目的时学习UniApp ，需要前置学习一下Vue3,之前只了解了Vue2觉得落后太多了。很多概念不是很清楚，这里来基本整理一遍再开始实战\nVue的工程化，单一职责，高内聚，低耦合的特点\n语法总结 首选创建一个官方推荐的脚手架：\n使用 Vite 创建项目(主流)\n1 npm create vite 1 2 3 4 5 6 7 PS D:\\CodeProject\\VueProject\u0026gt; npm create vite Need to install the following packages: create-vite@4.4.1 Ok to proceed? (y) y √ Project name: ... vite-project-typescript √ Select a framework: » Vue √ Select a variant: » TypeScript 设置项目名称：vite-project，vue类型项目，使用TypeScript 然后 cd 到vite-project-typescript, 安装依赖：\n1 npm install 启动项目：\n1 npm run dev 访问http://127.0.0.1:5173/： 此时的目录结构： 有几个共识的文件统一目录：\nsrc： 源码 src/main.ts: 入口文件 src/view： 路由组件 src/components：子组件目录 src/route: 路由目录 Composition API Composition API 是Vue.js .30 新的编写组件的方式，旧的就是Option API\n分别叫 组合式 API 和 选项式 API，组合就听着比较得复杂\nsetup 组合式API 就必须使用setup 这个方法，当 Vue 组件创建时，setup 函数将作为组件的入口被调用。在 setup 函数中可以定义和返回在组件模板中需要的所有数据和方法。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 \u0026lt;template\u0026gt; \u0026lt;div\u0026gt; \u0026lt;label\u0026gt; \u0026lt;input type=\u0026#34;radio\u0026#34; v-model=\u0026#34;selectedOption\u0026#34; value=\u0026#34;option1\u0026#34;\u0026gt; Option 1 \u0026lt;/label\u0026gt; \u0026lt;label\u0026gt; \u0026lt;input type=\u0026#34;radio\u0026#34; v-model=\u0026#34;selectedOption\u0026#34; value=\u0026#34;option2\u0026#34;\u0026gt; Option 2 \u0026lt;/label\u0026gt; \u0026lt;p\u0026gt;You selected: {{ selectedOption }}\u0026lt;/p\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script\u0026gt; import { ref } from \u0026#39;vue\u0026#39;; export default { name: \u0026#39;SimpleOptionsComponent\u0026#39;, setup() { const selectedOption = ref(\u0026#39;option1\u0026#39;); return { selectedOption }; } }; \u0026lt;/script\u0026gt; export default 是Vue2.js常见的导出组件的方式，但 Vue 3 建议使用命名导出来实现更灵活、清晰和强大的代码组织\n优化后：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 \u0026lt;template\u0026gt; \u0026lt;div\u0026gt; \u0026lt;label\u0026gt; \u0026lt;input type=\u0026#34;radio\u0026#34; v-model=\u0026#34;selectedOption\u0026#34; value=\u0026#34;option1\u0026#34;\u0026gt; Option 1 \u0026lt;/label\u0026gt; \u0026lt;label\u0026gt; \u0026lt;input type=\u0026#34;radio\u0026#34; v-model=\u0026#34;selectedOption\u0026#34; value=\u0026#34;option2\u0026#34;\u0026gt; Option 2 \u0026lt;/label\u0026gt; \u0026lt;p\u0026gt;You selected: {{ selectedOption }}\u0026lt;/p\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script setup lang=\u0026#34;ts\u0026#34;\u0026gt; import { ref } from \u0026#39;vue\u0026#39;; const selectedOption = ref(\u0026#39;option1\u0026#39;); export { selectedOption }; \u0026lt;/script\u0026gt; 看起来有些简陋，还使用官方推荐的API 创建一个组件：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 \u0026lt;template\u0026gt; \u0026lt;div\u0026gt; \u0026lt;label\u0026gt; \u0026lt;input type=\u0026#34;radio\u0026#34; v-model=\u0026#34;selectedOption\u0026#34; value=\u0026#34;option1\u0026#34;\u0026gt; Option 1 \u0026lt;/label\u0026gt; \u0026lt;label\u0026gt; \u0026lt;input type=\u0026#34;radio\u0026#34; v-model=\u0026#34;selectedOption\u0026#34; value=\u0026#34;option2\u0026#34;\u0026gt; Option 2 \u0026lt;/label\u0026gt; \u0026lt;p\u0026gt;You selected: {{ selectedOption }}\u0026lt;/p\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script\u0026gt; import { defineComponent, ref } from \u0026#39;vue\u0026#39;; export default defineComponent({ setup() { const selectedOption = ref(\u0026#39;option1\u0026#39;); return { selectedOption }; } }); \u0026lt;/script\u0026gt; 使用 defineComponent API 可以更清晰地表达组件的结构和选项，并且获得更好的类型推断和编辑器支持\nVue3.js 所有的组合式API 每个生命走起函数都必须先导入才可以使用，并且所有的生命周期函数都需要放在setup中，后面会慢慢看到 Vue3.js的组件编程风格非常多官方还是推荐 defineComponent 这样定义一个组件\nref 其中ref是组合式API 中的一部分，const selectedOption = ref('option1');其中的 selectedOption 是一个可变的响应式的引用变量，这个组件被其他地方使用的时候，会让这个变量关联给其他地方使用达到响应式双向绑定的目的\nref 是一个响应式的API,可以用来定义所有类型的数据，包括Node节点和组件，上面个例子中使用ref创建了额一个响应式的数据对象，返回了一个可以最该数据变化的引用，在后面提供一种方式来修改selectedOption的值，也就是通过下面方式改变：\n1 2 3 4 5 6 7 selectedOption.value = \u0026#39;option2\u0026#39;; // 或者 const { value } = selectedOption; value = \u0026#39;option2\u0026#39;; //或者 selectedOption.value.set(\u0026#39;option2\u0026#39;); ref接受的是一个泛型的入参（），上上个例子中使用了TS的自动推导，绑定了一个字符类型的参数，是一个最简单的绑定示例，ref 还可以绑定对象，数组，dom元素和子组件，功能强大，比较抽象，如果熟悉Vue2理解难度会小一些。\nref绑定dom 元素或子组件的时间必须在对应的js代码中使用red API 声明变量的名称，并且必须要return，入参类型名称也要定义好\n最后注意使用ref声明的变量都会变成对象，任何Ref对象的值必须通过xxx.value 才能正确获取。\nreactive 这个　API 与ref非常相似，区别是reactive 只能绑定对象，数组，使用这个API好处就是对其绑定的数据进行操作非常人性化，可以直接操作\n例子：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 \u0026lt;template\u0026gt; \u0026lt;div\u0026gt; \u0026lt;p\u0026gt;Count: {{ state.counter }}\u0026lt;/p\u0026gt; \u0026lt;button @click=\u0026#34;increment\u0026#34;\u0026gt;Increment\u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script lang=\u0026#34;ts\u0026#34;\u0026gt; import { defineComponent, reactive } from \u0026#39;vue\u0026#39;; interface State { counter: number; } export default defineComponent({ setup() { // 创建一个响应式对象 const state: State = reactive({ counter: 0, }); // 增加计数器的方法 const increment = () =\u0026gt; { state.counter++; }; return { state, increment, }; }, }); \u0026lt;/script\u0026gt; 注意使用这个API对数组操作重置的时候，不要强行改变数据的响应性 ，不能直接赋值空数组而是使数组长度设置为0。\ntoRef \u0026amp; toRefs toRef 创建一个Ref对象，转换Reactive对象的某个关键字段为Ref变量\ntoRefs 创建一个新的对象，把它的每一个字段都是Reactive对象各字段的Ref变量\ntoRef 简单用法：\n1 2 3 const ages = reactive([\u0026#39;17\u0026#39;,\u0026#39;18\u0026#39;,\u0026#39;19\u0026#39;]) const a = toRef(ages,3) console.log(a.value) toRefs 简单用法：\n1 2 const names = reactive([\u0026#39;tom\u0026#39;,\u0026#39;andy\u0026#39;,\u0026#39;bob\u0026#39;]) const name = toRefs(names) 注意使用toRefs 转换后 使用解构赋值不会失去响应性，但是直接解构Reactive不会具有响应性 ES6解构示例：\n1 2 const {name1,name2,name3} = toRefs(names) name1.value(\u0026#39;mili\u0026#39;) watch 示例:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 \u0026lt;template\u0026gt; \u0026lt;div\u0026gt; \u0026lt;p\u0026gt;Count: {{ count }}\u0026lt;/p\u0026gt; \u0026lt;button @click=\u0026#34;increment\u0026#34;\u0026gt;Increment\u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script\u0026gt; import { ref, watch } from \u0026#39;vue\u0026#39;; export default { setup() { const count = ref(0); // 使用watch函数来观察count的变化 watch(count, (newValue, oldValue) =\u0026gt; { console.log(\u0026#39;Count changed:\u0026#39;, newValue, oldValue); }); const increment = () =\u0026gt; { count.value++; }; return { count, increment }; } }; \u0026lt;/script\u0026gt; 使用watch监听一个用ref定义的一个响应式变量\nwatchEffect watchEffect不需要显式地指定要观察的变量,用于自动追踪在回调函数中使用的所有响应式数据，并在任何一个数据发生变化时触发回调函数，示例：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 \u0026lt;template\u0026gt; \u0026lt;div\u0026gt; \u0026lt;p\u0026gt;Count: {{ count }}\u0026lt;/p\u0026gt; \u0026lt;button @click=\u0026#34;increment\u0026#34;\u0026gt;Increment\u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script\u0026gt; import { ref, watchEffect } from \u0026#39;vue\u0026#39;; export default { setup() { const count = ref(0); // 使用watchEffect函数来观察响应式数据的变化 watchEffect(() =\u0026gt; { console.log(\u0026#39;Count changed:\u0026#39;, count.value); }); const increment = () =\u0026gt; { count.value++; }; return { count, increment }; } }; \u0026lt;/script\u0026gt; 简化了watch的操作，但是监听不了响应式的变量变化前后的值\ncomputed computed用于创建一个计算属性的API，它的值基于其他响应式数据计算出来的。\n示例：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 \u0026lt;template\u0026gt; \u0026lt;div\u0026gt; \u0026lt;p\u0026gt;First Name: {{ firstName }}\u0026lt;/p\u0026gt; \u0026lt;p\u0026gt;Last Name: {{ lastName }}\u0026lt;/p\u0026gt; \u0026lt;p\u0026gt;Full Name: {{ fullName }}\u0026lt;/p\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script\u0026gt; import { ref, computed } from \u0026#39;vue\u0026#39;; export default { setup() { const firstName = ref(\u0026#39;John\u0026#39;); const lastName = ref(\u0026#39;Doe\u0026#39;); // 使用computed函数创建计算属性fullName const fullName = computed(() =\u0026gt; { return firstName.value + \u0026#39; \u0026#39; + lastName.value; }); return { firstName, lastName, fullName }; } }; \u0026lt;/script\u0026gt; 这个计算属性也可以通过调用特定的函数方法来计算，使用这个API主要是为了更好的性能，避免重复计算，这个API 会有缓存的设计。\n指令 VUE中非常常见的一些语法糖，用于简化原生HTML的写法\n内置指令 v-model：用于在表单元素和组件之间创建双向数据绑定。它可以简化表单元素的值和Vue实例中的数据之间的同步。\nv-if：根据表达式的值来条件性地渲染元素。如果表达式的值为真，则元素会被渲染；如果为假，则元素会被移除。\nv-show：根据表达式的值来切换元素的显示和隐藏。如果表达式的值为真，则元素会显示；如果为假，则元素会隐藏，但仍然占据DOM空间。\nv-for：用于循环渲染列表中的元素。它可以遍历数组或对象，并为每个元素生成对应的DOM节点或组件实例。\nv-bind（简写为:）：用于动态地绑定属性或组件的属性。可以将表达式的值绑定到元素的属性或组件的属性上。\nv-on（简写为@）：用于监听DOM事件或组件自定义事件，并在事件触发时执行相应的方法。\nv-text：用于将表达式的值作为元素的文本内容进行渲染。\nv-html：用于将表达式的值作为HTML内容进行渲染。 如果熟悉VUE3 就会很简单上手啦\n钩子函数 生命周期钩子函数，在官网的选项式API介绍中有12个钩子函数，这里介绍一下比较常见的几个钩子函数：\nbeforeCreate：当指令第一次绑定到元素并却在挂载父组件之前调用，无法访问组件的数据，方法和DOM元素\ncreated：在组件实例被创建后立即调用。在这个钩子函数中，组件实例已经创建完成，可以访问到组件的数据、方法和DOM元素。\nbeforeMount：在组件挂载到DOM之前调用。在这个钩子函数中，组件的模板已经编译完成，但尚未插入到DOM中。\nmounted：在组件挂载到DOM后调用。在这个钩子函数中，组件已经被插入到DOM中，可以访问到组件的DOM元素。\nbeforeUpdate：在组件更新之前调用。在这个钩子函数中，组件的数据发生变化，但DOM尚未更新。\nupdated：在组件更新之后调用。在这个钩子函数中，组件的数据已经更新，DOM也已经更新完成。\nbeforeUnmount：在组件卸载之前调用。在这个钩子函数中，组件尚未从DOM中移除。\nunmounted：在组件卸载之后调用。在这个钩子函数中，组件已经从DOM中移除。\n1 2 3 4 5 6 7 8 9 10 import { onMounted } from \u0026#39;vue\u0026#39;; export default { setup() { onMounted(() =\u0026gt; { // 在组件挂载到 DOM 后执行的逻辑 console.log(\u0026#39;组件已挂载到 DOM\u0026#39;); }); } }; 插槽 插槽（slot）就是在使用子组件的时候，在中使用类似html标签，在子组件里传入任意模板代码以及HTML代码\n使用示例：\n1 2 3 4 5 6 7 8 9 10 11 12 13 \u0026lt;!-- ParentComponent.vue --\u0026gt; \u0026lt;template\u0026gt; \u0026lt;div\u0026gt; \u0026lt;h1\u0026gt;父组件\u0026lt;/h1\u0026gt; \u0026lt;slot\u0026gt;\u0026lt;/slot\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script\u0026gt; export default { name: \u0026#39;ParentComponent\u0026#39;, }; \u0026lt;/script\u0026gt; 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 \u0026lt;!-- App.vue --\u0026gt; \u0026lt;template\u0026gt; \u0026lt;div\u0026gt; \u0026lt;ParentComponent\u0026gt; \u0026lt;h2\u0026gt;子组件插槽内容\u0026lt;/h2\u0026gt; \u0026lt;p\u0026gt;这是子组件插槽的默认内容\u0026lt;/p\u0026gt; \u0026lt;/ParentComponent\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script\u0026gt; import { defineComponent } from \u0026#39;vue\u0026#39;; import ParentComponent from \u0026#39;./ParentComponent.vue\u0026#39;; export default defineComponent({ name: \u0026#39;App\u0026#39;, components: { ParentComponent, }, }); \u0026lt;/script\u0026gt; 以上的代码是一个叫匿名插槽的使用方法，还有叫具名插槽的使用方法\n具名插槽：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 \u0026lt;!-- ParentComponent.vue --\u0026gt; \u0026lt;template\u0026gt; \u0026lt;div\u0026gt; \u0026lt;h1\u0026gt;父组件\u0026lt;/h1\u0026gt; \u0026lt;slot name=\u0026#34;content\u0026#34;\u0026gt;\u0026lt;/slot\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script\u0026gt; import { defineComponent } from \u0026#39;vue\u0026#39;; export default defineComponent({ name: \u0026#39;ParentComponent\u0026#39;, }); \u0026lt;/script\u0026gt; 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 \u0026lt;!-- App.vue --\u0026gt; \u0026lt;template\u0026gt; \u0026lt;div\u0026gt; \u0026lt;ParentComponent\u0026gt; \u0026lt;template v-slot:content\u0026gt; \u0026lt;p\u0026gt;子组件的插槽内容\u0026lt;/p\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;/ParentComponent\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script\u0026gt; import { defineComponent } from \u0026#39;vue\u0026#39;; import ParentComponent from \u0026#39;./ParentComponent.vue\u0026#39;; export default defineComponent({ name: \u0026#39;App\u0026#39;, components: { ParentComponent, }, }); \u0026lt;/script\u0026gt; 当父组件没有传入插槽内容时，会使用默认的内容来显示，默认插槽和具名插槽都支持这个功能\nCSS处理 动态绑定 使用变量来绑定class名称，使用:class来动态修改元素的class，示例：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 \u0026lt;template\u0026gt; \u0026lt;div :class=\u0026#34;{ active: isActive, \u0026#39;text-bold\u0026#39;: isBold }\u0026#34;\u0026gt; Dynamic Class Example \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script\u0026gt; import { ref } from \u0026#39;vue\u0026#39;; export default { setup() { const isActive = ref(true); const isBold = ref(false); return { isActive, isBold, }; }, }; \u0026lt;/script\u0026gt; 也可以传入一个数组绑定多个class：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 \u0026lt;template\u0026gt; \u0026lt;div :class=\u0026#34;[isActive ? \u0026#39;active\u0026#39; : \u0026#39;\u0026#39;, isBold ? \u0026#39;text-bold\u0026#39; : \u0026#39;\u0026#39;]\u0026#34;\u0026gt; Dynamic Class Example \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script\u0026gt; import { reactive } from \u0026#39;vue\u0026#39;; export default { setup() { const state = reactive({ isActive: true, isBold: false, }); return { ...state, }; }, }; \u0026lt;/script\u0026gt; 还可以使用:style动态修改内联样式：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 \u0026lt;template\u0026gt; \u0026lt;div :style=\u0026#34;customStyle\u0026#34;\u0026gt; Inline Style Example \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script\u0026gt; import { reactive } from \u0026#39;vue\u0026#39;; export default { setup() { const customStyle = reactive({ color: \u0026#39;red\u0026#39;, fontSize: \u0026#39;20px\u0026#39;, backgroundColor: \u0026#39;lightblue\u0026#39;, }); return { customStyle, }; }, }; \u0026lt;/script\u0026gt; 使用v-bind 动态修改style:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 html \u0026lt;template\u0026gt; \u0026lt;div\u0026gt; \u0026lt;button @click=\u0026#34;changeColor\u0026#34;\u0026gt;改变颜色\u0026lt;/button\u0026gt; \u0026lt;p :style=\u0026#34;dynamicStyle\u0026#34;\u0026gt;这是一个示例文本\u0026lt;/p\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script\u0026gt; import { ref } from \u0026#39;vue\u0026#39;; export default { setup() { // 创建响应式的数据 const dynamicStyle = ref({ color: \u0026#39;red\u0026#39;, fontSize: \u0026#39;16px\u0026#39; }); // 改变颜色的方法 const changeColor = () =\u0026gt; { dynamicStyle.value.color = \u0026#39;blue\u0026#39;; }; return { dynamicStyle, changeColor }; } }; \u0026lt;/script\u0026gt; 这个是vue3.2.0以后的新功能，此时的CSS响应式属性的更改不会触发模板的重新渲染。\nCSS 作用域 CSS 作用域是全局的，为了避免污染其他组件，Vue 在style 标签加上关键字scoped避免这个问题，编译过后都会带有一个data-v-xxxx的属性，是一个随机的Hash值，同一个组件的Hash是相同并且是唯一的 带有此关键字的元素生成的样式权重是高于全局CSS的 示例：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 \u0026lt;template\u0026gt; \u0026lt;div\u0026gt; \u0026lt;p class=\u0026#34;global-style\u0026#34;\u0026gt;这是全局样式\u0026lt;/p\u0026gt; \u0026lt;p class=\u0026#34;scoped-style\u0026#34;\u0026gt;这是局部样式\u0026lt;/p\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;style scoped\u0026gt; /* 全局样式 */ .global-style { color: blue; } /* 局部样式 */ .scoped-style { color: red; } \u0026lt;/style\u0026gt; Style Module Vue3 新推出的方案，通过给DOM元素添加自定义属性的方式避免冲突，比较激进，示例：\n1 2 3 4 5 6 7 8 9 \u0026lt;template\u0026gt; \u0026lt;p :class=\u0026#34;classes.msg\u0026#34;\u0026gt;hello\u0026lt;/p\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;style module=\u0026#34;classes\u0026#34;\u0026gt; .msg { color: #00ff00; } \u0026lt;/style\u0026gt; 编译以后会成为一个hash值的类型绑定在DOM元素上，会渲染一个绿色的hello\n使用style标签作为一个变量，module 给变量一个名称，绑定到DOM 中渲染。\nuseCssModule Vue3的一个全新的API，使用JavaScript操作CSS Module. 示例：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 \u0026lt;template\u0026gt; \u0026lt;p :class=\u0026#34;$style.msg\u0026#34;\u0026gt; \u0026lt;span :class=\u0026#34;$style.text\u0026#34;\u0026gt;hello\u0026lt;/span\u0026gt; \u0026lt;/p\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script lang=\u0026#34;ts\u0026#34;\u0026gt; import {defineComponent, useCssModule} from \u0026#39;vue\u0026#39; export default defineComponent({ setup(){ const style = useCssModule() console.log(style) }, }) \u0026lt;/script\u0026gt; \u0026lt;style module\u0026gt; .msg{ color: #00ff00; } .text{ font-size: 14px; } \u0026lt;/style\u0026gt; 将style标签内容作为一个变量$style,与DOM标签的class 绑定\nCSS 预处理器 CSS 预处理器是一个扩展CSS 语言的工具，给CSS提供了一些额外的功能和特性，使CSS 更易于编写，组织和维护。常见的有less,sass,Stylus Vite 已经内置了对预处理文件的支持，以less 为例：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 \u0026lt;template\u0026gt; \u0026lt;p :class=\u0026#34;$style.msg\u0026#34;\u0026gt; \u0026lt;span :class=\u0026#34;$style.text\u0026#34;\u0026gt;hello\u0026lt;/span\u0026gt; \u0026lt;/p\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script lang=\u0026#34;ts\u0026#34;\u0026gt; import {defineComponent, useCssModule} from \u0026#39;vue\u0026#39; export default defineComponent({ setup(){ const style = useCssModule() console.log(style) }, }) \u0026lt;/script\u0026gt; \u0026lt;style lang=\u0026#34;less\u0026#34; scoped\u0026gt; @color-black:#333333; @color-red:#ff0000; .msg{ color: @color-black; } .text{ color:@color-red } \u0026lt;/style\u0026gt; 在less 预处理其中可以在style 标签中使用定义CSS颜色为一个变量，在其他地方使用，代码复用的思想。\nstyle 标签中scoped 的作用表示 该style 标签的作用域只在当前组件的DOM元素中。起到了一定的隔离作用，更符合组件化的规范。\nv\n","date":"2023-07-05T14:39:35+08:00","image":"https://munihehacker/my-blog.github.io/p/vue3-%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/title_hu10926b4f8cbed773a1aed12861962ad9_27587_120x120_fill_q75_box_smart1.jpg","permalink":"https://munihehacker/my-blog.github.io/p/vue3-%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/","title":"Vue3 基础语法 学习笔记"},{"content":"查看哪些docker镜像：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 root@koala9527:/home/jijiwaiwai/my-project/jupyter-notebook# sudo docker search jupyter NAME DESCRIPTION STARS OFFICIAL AUTOMATED jupyter/scipy-notebook Scientific Jupyter Notebook Python Stack fro… 406 jupyter/tensorflow-notebook Scientific Jupyter Notebook Python Stack w/ … 345 jupyter/all-spark-notebook Python, Scala, R and Spark Jupyter Notebook … 417 jupyter/pyspark-notebook Python and Spark Jupyter Notebook Stack from… 277 jupyter/datascience-notebook Data Science Jupyter Notebook Python Stack f… 1027 jupyterhub/singleuser single-user docker images for use with Jupyt… 45 [OK] jupyterhub/jupyterhub JupyterHub: multi-user Jupyter notebook serv… 326 [OK] jupyter/minimal-notebook Minimal Jupyter Notebook Python Stack from h… 183 jupyter/base-notebook Base image for Jupyter Notebook stacks from … 203 jupyterhub/k8s-hub 22 jupyterhub/k8s-network-tools 2 jupyterhub/configurable-http-proxy node-http-proxy + REST API 6 [OK] jupyterhub/k8s-singleuser-sample 10 jupyter/nbviewer Jupyter Notebook Viewer 32 [OK] jupyter/r-notebook R Jupyter Notebook Stack from https://github… 54 jupyterhub/k8s-image-awaiter 2 jupyter/repo2docker Turn git repositories into Jupyter enabled D… 21 jupyterhub/k8s-secret-sync 1 jupyterhub/jupyterhub-onbuild onbuild version of JupyterHub images 6 bitnami/jupyter-base-notebook 39 jupyter/demo (DEPRECATED) Demo of the IPython/Jupyter Not… 16 jupyterhub/k8s-image-cleaner 1 jupyterhub/k8s-binderhub 3 jupyterhub/k8s-pre-puller 1 参考官网： https://jupyter-docker-stacks.readthedocs.io/en/latest/using/common.html 可以看到各个镜像的简要介绍\n我选择了第一个： 包含来自科研科学类的Python生态系统的热门软件包 编写docker-compose.yml.后期维护有记录：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 version: \u0026#34;3.3\u0026#34; services: scipy-notebook: image: jupyter/scipy-notebook:latest container_name: jupyter-notebook tty: True user: root restart: always ports: - 8899:8888 volumes: - ${PWD}/.aws:/home/jovyan/.aws - ${PWD}/work:/home/jovyan/work environment: - REPOS=/home/jovyan/work/git - JUPYTER_TOKEN=******** - JUPYTER_ENABLE_LAB=yes - NB_UID=1000 #$(id -u) - NB_GID=1000 #(id -g) 注意要 UID NB_GID 需要设置一下，属于linux 的用户组管理，会影响 Jupyter 服务器进程以及在容器内创建或挂载文件时的权限和所有权。\n我这里设置的我安装系统后创建的第一个用户，通过id查看，不建议用root 用户，貌似会启动不起来。\n如果不设置就会报错： 启动命令：\n1 docker-compose -d 容器运行起来后宿主机的 ${PWD}/work 目录需要设置用户权限，我的这个目录是root 用户权限创建的其他用户不用进行创建文件的操作，需要使用chmod 777 是其他用户组有读写权限：\n1 2 3 4 5 6 7 8 9 root@koala9527:/home/*****/my-project/jupyter-notebook# ls -l 总计 8 -rw-r--r-- 1 root root 471 7月 2 16:06 docker-compose.yml drwxr-xr-x 2 root root 4096 7月 2 15:25 work root@koala9527:/home/*****/my-project/jupyter-notebook# chmod 777 work/ root@koala9527:/home/*****/my-project/jupyter-notebook# ls -l 总计 8 -rw-r--r-- 1 root root 471 7月 2 16:06 docker-compose.yml drwxrwxrwx 2 root root 4096 7月 2 15:25 work 通过内网访问: 验证使用： 新建一个Notebook项目尝试运行：\n","date":"2023-07-02T14:13:08+08:00","image":"https://munihehacker/my-blog.github.io/p/%E5%AE%89%E8%A3%85jupyter-notebook/title2_huca8818e6bf770b0be933c338b86b3acd_35606_120x120_fill_q75_box_smart1.jpg","permalink":"https://munihehacker/my-blog.github.io/p/%E5%AE%89%E8%A3%85jupyter-notebook/","title":"安装Jupyter Notebook"},{"content":"前言 最近在研究uniapp，一个可以生成多端的应用的工具，我主要是主要是生成微信小程序和支付宝小程序，自己也是在这方面工作，只不过是后端相关，最近开始研究前端相关的内容，已经上架了两个小程序，写的很拉跨，很多冗余的代码。因为没有参考成熟的项目，需要什么加什么，没有考虑封装共用，每一个页面都有请求接口需要获取用户的openid，js就写得很长。\n今天尝试一下从0开始新建一个Uniapp项目到获取Openid得全局封装，说明一下没有参考其他教程项目，仅仅是个人的习惯方案。\n","date":"2023-06-29T11:43:52+08:00","permalink":"https://munihehacker/my-blog.github.io/p/uniapp-%E4%BB%8E%E9%9B%B6%E5%90%AF%E5%8A%A8%E5%88%B0-%E5%85%A8%E5%B1%80%E8%8E%B7%E5%8F%96openid%E7%9A%84%E5%B0%81%E8%A3%85/","title":"Uniapp 从零启动到 全局获取Openid的封装"},{"content":"前言 一直在用阿里云的免费的容器镜像服务来存放自己打包好的容器镜像，虽然很好用，但是总觉得这些大厂免费的服务最后总是要收费，想搭建一个自己得私有镜像仓库。\n自己以前搭建过 nexus 仓库，但是使用的很少，感觉跟jenkins 一样，用java写的，界面很古老，不是专业的docker镜像仓库。\n前段时间把自己的树莓派都卖了，入手了一个N5101，今天在这个机器上安装 大名鼎鼎的开源的企业级镜像仓库Harbor。\nHarbor 简介 Harbor英文单词意思是港湾，港湾一般是停放货物，就会联想到集装箱（container）, 码头工人（Docker）。\n容器（container）是Docker镜像的运行实例 ，Docker 是一个让 Container 标准话的方案 /工具。\nHarbor 是一个专业的存储Docker镜像的企业级服务软件。Harbor是由VMware公司开源的企业级的Docker Registry管理项目，有非常丰富专业的功能，例如： 多租户内容签名和验证，安全性与漏洞分析，审计日志记录，身份集成和基于角色的访问控制，镜像复制分发，自动清理，Webhook等等。\n安装 Harbor安装也非常得简单，自己是因为在内网部署的，有一些关于内网穿透的配置，可能和大部分的人的安装流程可能有些差别\n下载离线安装脚本配置文件 访问官方GitHub地址：https://github.com/goharbor/harbor 找到并下载下载最新的发行版本： 我选择的是离线安装版本，自己的系统ubuntu，找一个专门存放Harbor的配置安装脚本的文件夹再新建两个文件夹，一个存放安装的映射的数据，一个存放配置安装文件:\n1 2 mkdir data mkdir harbor 然后下载解压安装包：\n1 2 wget https://github.com/goharbor/harbor/releases/download/v2.8.2/harbor-online-installer-v2.8.2.tgz tar zxvf harbor-online-installer-v2.8.2.tgz ./habor/ 初始化配置文件\n1 cp harbor.yml.tmpl harbor.yml 修改配置文件： 重点来，一共需要修改6个地方 修改配置文件\n1 vim harbor.yml 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 # Configuration file of Harbor # The IP address or hostname to access admin UI and registry service. # DO NOT use localhost or 127.0.0.1, because Harbor needs to be accessed by external clients. # 修改第一处 不重要，下面external_url设置的会覆盖这里 hostname: harbor.****.**** # http related config http: # port for http, default is 80. If https enabled, this port will redirect to https port # 修改第二处 ，服务暴露穿透的端口，和现有服务冲突了，我就随便修了一个 port: 82 # https related config # 修改第三处 ，关闭自带SSL的 服务 #https: # https port for harbor, default is 443 # port: 443 # The path of cert and key files for nginx # certificate: /your/certificate/path # private_key: /your/private/key/path # # Uncomment following will enable tls communication between all harbor components #internal_tls: # # set enabled to true means internal tls is enabled # enabled: false # # put your cert and key files on dir # dir: /etc/harbor/tls/internal # Uncomment external_url if you want to enable external proxy # And when it enabled the hostname will no longer used # 修改第四处 ，非常重要。运行起来之后拉去镜像的地址都是使用这个地址。可以用HTTPS，在穿透之后，最外层的入口必须使用HTTPS服务 external_url: https://harbor.****.**** # The initial password of Harbor admin # It only works in first time to install harbor # Remember Change the admin password from UI after launching Harbor. # 修改第五处 设置运行起来后的默认密码，因为服务会暴露在公网，所有安全非常重要 harbor_admin_password: ********* # Harbor DB configuration database: # The password for the root user of Harbor DB. Change this before any production use. password: root123 # The maximum number of connections in the idle connection pool. If it \u0026lt;=0, no idle connections are retained. max_idle_conns: 100 # The maximum number of open connections to the database. If it \u0026lt;= 0, then there is no limit on the number of open connections. # Note: the default number of connections is 1024 for postgres of harbor. max_open_conns: 900 # The maximum amount of time a connection may be reused. Expired connections may be closed lazily before reuse. If it \u0026lt;= 0, connections are not closed due to a connection\u0026#39;s age. # The value is a duration string. A duration string is a possibly signed sequence of decimal numbers, each with optional fraction and a unit suffix, such as \u0026#34;300ms\u0026#34;, \u0026#34;-1.5h\u0026#34; or \u0026#34;2h45m\u0026#34;. Valid time units are \u0026#34;ns\u0026#34;, \u0026#34;us\u0026#34; (or \u0026#34;µs\u0026#34;), \u0026#34;ms\u0026#34;, \u0026#34;s\u0026#34;, \u0026#34;m\u0026#34;, \u0026#34;h\u0026#34;. conn_max_lifetime: 5m # The maximum amount of time a connection may be idle. Expired connections may be closed lazily before reuse. If it \u0026lt;= 0, connections are not closed due to a connection\u0026#39;s idle time. # The value is a duration string. A duration string is a possibly signed sequence of decimal numbers, each with optional fraction and a unit suffix, such as \u0026#34;300ms\u0026#34;, \u0026#34;-1.5h\u0026#34; or \u0026#34;2h45m\u0026#34;. Valid time units are \u0026#34;ns\u0026#34;, \u0026#34;us\u0026#34; (or \u0026#34;µs\u0026#34;), \u0026#34;ms\u0026#34;, \u0026#34;s\u0026#34;, \u0026#34;m\u0026#34;, \u0026#34;h\u0026#34;. conn_max_idle_time: 0 # The default data volume # 修改第六处，harbor 数据存放的地方，需要一个空余空间很大的文件夹，自行决定 data_volume: /***/**** ... 安装完成后的配置 运行在解压的目录下的install.sh脚本\n1 ./install.sh 会启动9个容器 此时内网访问已经可以了： 配置内网穿透frp，这里frp 的安装自己也在掘金也有介绍，这里就略过了 在frpc.ini 新加一个配置：\n1 2 3 4 5 [n5105-harbor] type = tcp local_port = 82 local_ip = 127.0.0.1 remote_port = 37151 重启frp\n然后在外网的机器上，新建一个域名解析：harbor.. ,反向代理到这个frp的远程端口remote_port: 然后再修改一个反向代理配置才能推送镜像成功,注释掉proxy_set_header Host $host;： proxy_set_header作用是用于设置传递给后端服务器的HTTP头信息，可能因为harbor 自身没有启动SSL的支持，但是有反向代理的带有SSL的支持会有问题，如果注释掉这个反向代理的Nginx 配置推送镜像会报错unknown blob\n结束 验证最基础的推拉镜像是否正常 最先需要用账号（admin）和密码在命令行登录获得这个私有镜像仓库的推送权限：\n然后使用设置的密码登录harbor，新建一个公开项目：\n进入项目，找到推送命令，然后在本地找一个简单镜像重新打包\n自己找了一个本地的consul镜像，重新打tag ，推送镜像，命令如下：\n1 2 docker tag consul:latest harbor.****.****/test/consul:latest docker push harbor.tuwei.space/test/consul:latest 推送成功： 然后在其他的机器上直接执行拉取命令：\n1 docker pull harbor.****.****/test/consul:latest 到此完结，最简单的安装验证，Harbor 还是比较占用系统资源的，现在小主机很火，很多人都在弄ALL IN ONE，HomeLab。使用内网穿透部署这种镜像管理的工具性价比还是比较高的。\n","date":"2023-06-27T21:34:09+08:00","image":"https://munihehacker/my-blog.github.io/p/%E8%AE%B0%E5%BD%95%E4%B8%80%E6%AC%A1%E5%AE%89%E8%A3%85%E5%BC%80%E6%BA%90%E4%BC%81%E4%B8%9A%E7%BA%A7%E9%95%9C%E5%83%8F%E4%BB%93%E5%BA%93%E7%AE%A1%E7%90%86%E8%BD%AF%E4%BB%B6harbor/title_hua6c10b1586b1f1d3be55f522340b661c_91215_120x120_fill_box_smart1_3.png","permalink":"https://munihehacker/my-blog.github.io/p/%E8%AE%B0%E5%BD%95%E4%B8%80%E6%AC%A1%E5%AE%89%E8%A3%85%E5%BC%80%E6%BA%90%E4%BC%81%E4%B8%9A%E7%BA%A7%E9%95%9C%E5%83%8F%E4%BB%93%E5%BA%93%E7%AE%A1%E7%90%86%E8%BD%AF%E4%BB%B6harbor/","title":"记录一次安装开源企业级镜像仓库管理软件：Harbor"},{"content":"前言 两年前买了四台树莓派4B 组了一个K8s 集群，在知乎，掘金发了两篇搭建的教程，一直都有人收藏，网上的教程也很少，今年年初看到树莓派溢价非常多，几乎没有做什么应用搭建在上面，就拿过来组集群写些教程使用了，所以索性咸鱼几乎翻倍都出了。 最近看到随身wifi棒子特别的火，又有人搭建利用随身wifi的Docker Swarm集群，自己有想动手弄一个，又在咸鱼淘了四个处理器为RK3568的机器，处理器配置比树莓派配置要好，但是只有4G内存，主要是才90元一个，买了12V DC电源。不到400。 如果对kubernetes基本概念不熟悉，请务必找到之前文章去熟悉一下，之前的文章的细节描述非常仔细清楚~\n系统是自带的Armbian:\n1 2 root@panther-x2-main:~# uname -a Linux panther-x2-main 6.1.28-rockchip64 #1 SMP PREEMPT Thu May 11 14:04:52 UTC 2023 aarch64 aarch64 aarch64 GNU/Linux Armbian是轻量级的Debian系统，Linux有两大分支系列，一个是Debian 一个是Redhat。每个系列又有不同的更细的分支。 Redhat是商业公司维护的发行版本，Debian是社区组织维护的发行版本 一般个人折腾用Debian 社区强大，公司的生产环境用Centos。\n开始 更改机器主机名称（hostname） 因为系统刷机后系统的名称完全一样，需要修改名称才能分辨他们\n一台Master节点 ，3台Work节点， 需要把四台机器的分为改为：\n1 2 3 4 panther-x2-main panther-x2-1 panther-x2-2 panther-x2-3 每台机器设置分别需要修改\u0026quot;/etc/hostname\u0026quot;文件内容 用Master节点举一个例子：\n1 vim /etc/hostname 改完后的效果：\n1 2 3 4 5 6 7 8 root@panther-x2-main:~# cat /etc/hostname panther-x2-main root@panther-x2-1:~# cat /etc/hostname panther-x2-1 root@panther-x2-2:~# cat /etc/hostname panther-x2-2 root@panther-x2-3:~# cat /etc/hostname panther-x2-3 设置静态IP 静态IP的作用就是让机器在内网环境下有一个固定的IP，不能让它每次重启有一个不一样的IP，那样机器之间就无法正常沟通了。\n每一台机器都需要执行一样的命令：\n1 2 3 4 5 6 sudo cat \u0026gt;\u0026gt; /etc/hosts \u0026lt;\u0026lt; EOF 192.168.2.191 panther-x2-main 192.168.2.192 panther-x2-1 192.168.2.193 panther-x2-2 192.168.2.194 panther-x2-3 EOF 关闭swap 内存交换空间 关闭它是为了保证Kubernetes集群的稳定性和可靠性，Swap分区是一种虚拟内存技术，当系统内存不足时，会将少用的内存数据交换到硬盘中，以便释放更多的内存空间给正在运行的进程使用。但是，当Swap分区被使用时，它会导致系统的性能下降，因为硬盘速度比内存慢得多。如果Kubernetes节点上的应用程序频繁地使用Swap分区，那么整个集群的性能就会受到影响，因此关闭Swap分区可以避免这种情况的发生\n每台机器都要执行\n1 vim /etc/default/armbian-zram-config 1 vim /etc/cron.d/armbian-truncate-logs 注释掉第三行\n然后注释掉最后一行：\n1 vim /etc/cron.daily/armbian-ram-logging 然后重启，验证swap是否被关闭：\n关闭SElinux 根据提示没有安装\n1 2 3 root@panther-x2-main:~# dpkg -s selinux-policy-default dpkg-query: package \u0026#39;selinux-policy-default\u0026#39; is not installed and no information is available Use dpkg --info (= dpkg-deb --info) to examine archive files. 关闭IPv4转发 IPv4 转发通常允许将网络流量从一个网络接口传输到另一个网络接口可能会导致安全漏洞。\n1 /etc/sysctl.conf 默认关闭了：\n安装一些软件 1 2 3 4 5 6 apt-get update apt-get install apt-transport-https \\ ca-certificates \\ curl \\ gnupg2 \\ software-properties-common 1 sudo apt-get install docker-ce docker-ce-cli containerd.io 配置docker 这个非常重要，Kubernetes官方指出在1.24之后删除了dockershim组件，我现在在要安装最新版的kubernetes1.27,默认的运行时是contained，而目前Docker 安装的默认运行时是docker-runc，所以需要切换Docker 的运行时。 偷了懒问了一下chatgpt 如何切换docker运行时，实测很准确\n最近因为某些原因Docker好多镜像拉取不下来，需要手动添加一下镜像源，需要如下修改：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 root@panther-x2-main:~# cat /etc/docker/daemon.json { \u0026#34;exec-opts\u0026#34;: [\u0026#34;native.cgroupdriver=systemd\u0026#34;], \u0026#34;registry-mirrors\u0026#34;: [ \u0026#34;https://docker.m.daocloud.io\u0026#34;, \u0026#34;https://dockerproxy.com\u0026#34;, \u0026#34;https://docker.mirrors.ustc.edu.cn\u0026#34;, \u0026#34;https://docker.nju.edu.cn\u0026#34; ], \u0026#34;default-runtime\u0026#34;: \u0026#34;containerd\u0026#34;, \u0026#34;runtimes\u0026#34;: { \u0026#34;containerd\u0026#34;: { \u0026#34;path\u0026#34;: \u0026#34;/usr/bin/containerd\u0026#34; } } } 最后验证一下：\n1 2 3 4 root@panther-x2-main:~# docker info | grep -i runtime Runtimes: containerd io.containerd.runc.v2 runc Default Runtime: containerd root@panther-x2-main:~# 安装最新版kubelet，kubeadm，kubectl 每个机器都有需要执行以下命令： 更新 apt 包索引并安装使用 Kubernetes apt 仓库所需要的包：\n1 2 sudo apt-get update sudo apt-get install -y apt-transport-https ca-certificates curl 下载 Google Cloud 公开签名秘钥：\n1 curl -fsSL https://packages.cloud.google.com/apt/doc/apt-key.gpg | sudo gpg --dearmor -o /etc/apt/keyrings/kubernetes-archive-keyring.gpg 添加 Kubernetes apt 仓库：\n1 echo \u0026#34;deb [signed-by=/etc/apt/keyrings/kubernetes-archive-keyring.gpg] https://apt.kubernetes.io/ kubernetes-xenial main\u0026#34; | sudo tee /etc/apt/sources.list.d/kubernetes.list 安装 kubelet、kubeadm 和 kubectl，之前使用树莓派安装的是1.20版本的，社区已经不支持和维护了，k8s版本迭代的还是很快的，目前是四个月一个小版本，一个月支持版本一个补丁，还是很快的，有很大的学习压力呀，还有关联到了各种的组件的支持 目前最新的版本是1.27，现在来根据官方文档安装：\n1 2 sudo apt-get install -y kubelet kubeadm kubectl sudo apt-mark hold kubelet kubeadm kubectl 前置设置 根据文档/etc/containerd/config.toml 更改驱动\ncontainerd config default \u0026gt; /etc/containerd/config.toml\n修改：/etc/containerd/config.toml\n将SystemdCgroup的值修改为true，将sandbox_image的值修改为国内镜像registry.cn-hangzhou.aliyuncs.com/google_containers/pause:3.8 然后重启contained:\n1 systemctl restart containerd 还可以做一下前置检查\n1 kubeadm init phase preflight 前置拉取镜像改名字： 由于某些原因直接拉去k8s所需要的镜像是拉取不下来的，只能参照官方的离线安装方案，先把同步到国内源的镜像拉取下来再改tag名称，最好做一个shell脚本，每台机器都需要执行一下拉取镜像，改tag名称： 脚本内容：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 root@panther-x2-main:~# cat pull_k8s_docker.sh MY_REGISTRY=registry.aliyuncs.com/google_containers K8S_VERSION=\u0026#34;v1.27.2\u0026#34; echo \u0026#34;\u0026#34; echo \u0026#34;==========================================================\u0026#34; echo \u0026#34;Pull Kubernetes for x64 v$K8S_VERSION Images from docker.io ......\u0026#34; echo \u0026#34;==========================================================\u0026#34; echo \u0026#34;\u0026#34; ## 拉取镜像%s/oldWords/newWords//g docker pull ${MY_REGISTRY}/kube-apiserver:$K8S_VERSION docker pull ${MY_REGISTRY}/kube-controller-manager:$K8S_VERSION docker pull ${MY_REGISTRY}/kube-scheduler:$K8S_VERSION docker pull ${MY_REGISTRY}/kube-proxy:$K8S_VERSION docker pull ${MY_REGISTRY}/pause:3.8 docker pull ${MY_REGISTRY}/etcd:3.5.7-0 docker pull coredns/coredns:1.10.1 ## 添加Tag docker tag ${MY_REGISTRY}/kube-apiserver:$K8S_VERSION registry.k8s.io/kube-apiserver:$K8S_VERSION docker tag ${MY_REGISTRY}/kube-scheduler:$K8S_VERSION registry.k8s.io/kube-scheduler:$K8S_VERSION docker tag ${MY_REGISTRY}/kube-controller-manager:$K8S_VERSION registry.k8s.io/kube-controller-manager:$K8S_VERSION docker tag ${MY_REGISTRY}/kube-proxy:$K8S_VERSION registry.k8s.io/kube-proxy:$K8S_VERSION docker tag ${MY_REGISTRY}/pause:3.8 registry.k8s.io/pause:3.8 docker tag ${MY_REGISTRY}/etcd:3.5.7-0 registry.k8s.io/etcd:3.5.7-0 docker tag coredns/coredns:1.10.1 registry.k8s.io/coredns:v1.10.1 开始安装 在Master 节点执行一下命令：\n1 sudo kubeadm init --image-repository=registry.aliyuncs.com/google_containers --kubernetes-version=v1.27.2 --apiserver-advertise-address=192.168.2.191 --pod-network-cidr=192.168.0.0/16 --ignore-preflight-errors=all 效果如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 root@panther-x2-main:~# sudo kubeadm init --image-repository=registry.aliyuncs.com/google_containers --kubernetes-version=v1.27.2 --apiserver-advertise-address=192.168.2.191 --pod-network-cidr=192.168.0.0/16 --ignore-preflight-errors=all [init] Using Kubernetes version: v1.27.2 [preflight] Running pre-flight checks [preflight] Pulling images required for setting up a Kubernetes cluster [preflight] This might take a minute or two, depending on the speed of your internet connection [preflight] You can also perform this action in beforehand using \u0026#39;kubeadm config images pull\u0026#39; W0611 22:16:04.216900 4263 images.go:80] could not find officially supported version of etcd for Kubernetes v1.27.2, falling back to the nearest etcd version (3.5.7-0) W0611 22:16:04.743772 4263 checks.go:835] detected that the sandbox image \u0026#34;registry.cn-hangzhou.aliyuncs.com/google_containers/pause:3.8\u0026#34; of the container runtime is inconsistent with that used by kubeadm. It is recommended that using \u0026#34;registry.aliyuncs.com/google_containers/pause:3.9\u0026#34; as the CRI sandbox image. [certs] Using certificateDir folder \u0026#34;/etc/kubernetes/pki\u0026#34; [certs] Generating \u0026#34;ca\u0026#34; certificate and key [certs] Generating \u0026#34;apiserver\u0026#34; certificate and key [certs] apiserver serving cert is signed for DNS names [kubernetes kubernetes.default kubernetes.default.svc kubernetes.default.svc.cluster.local panther-x2-main] and IPs [10.96.0.1 192.168.2.191] [certs] Generating \u0026#34;apiserver-kubelet-client\u0026#34; certificate and key [certs] Generating \u0026#34;front-proxy-ca\u0026#34; certificate and key [certs] Generating \u0026#34;front-proxy-client\u0026#34; certificate and key [certs] Generating \u0026#34;etcd/ca\u0026#34; certificate and key [certs] Generating \u0026#34;etcd/server\u0026#34; certificate and key [certs] etcd/server serving cert is signed for DNS names [localhost panther-x2-main] and IPs [192.168.2.191 127.0.0.1 ::1] [certs] Generating \u0026#34;etcd/peer\u0026#34; certificate and key [certs] etcd/peer serving cert is signed for DNS names [localhost panther-x2-main] and IPs [192.168.2.191 127.0.0.1 ::1] [certs] Generating \u0026#34;etcd/healthcheck-client\u0026#34; certificate and key [certs] Generating \u0026#34;apiserver-etcd-client\u0026#34; certificate and key [certs] Generating \u0026#34;sa\u0026#34; key and public key [kubeconfig] Using kubeconfig folder \u0026#34;/etc/kubernetes\u0026#34; [kubeconfig] Writing \u0026#34;admin.conf\u0026#34; kubeconfig file [kubeconfig] Writing \u0026#34;kubelet.conf\u0026#34; kubeconfig file [kubeconfig] Writing \u0026#34;controller-manager.conf\u0026#34; kubeconfig file [kubeconfig] Writing \u0026#34;scheduler.conf\u0026#34; kubeconfig file [kubelet-start] Writing kubelet environment file with flags to file \u0026#34;/var/lib/kubelet/kubeadm-flags.env\u0026#34; [kubelet-start] Writing kubelet configuration to file \u0026#34;/var/lib/kubelet/config.yaml\u0026#34; [kubelet-start] Starting the kubelet [control-plane] Using manifest folder \u0026#34;/etc/kubernetes/manifests\u0026#34; [control-plane] Creating static Pod manifest for \u0026#34;kube-apiserver\u0026#34; [control-plane] Creating static Pod manifest for \u0026#34;kube-controller-manager\u0026#34; [control-plane] Creating static Pod manifest for \u0026#34;kube-scheduler\u0026#34; [etcd] Creating static Pod manifest for local etcd in \u0026#34;/etc/kubernetes/manifests\u0026#34; W0611 22:16:26.878081 4263 images.go:80] could not find officially supported version of etcd for Kubernetes v1.27.2, falling back to the nearest etcd version (3.5.7-0) [wait-control-plane] Waiting for the kubelet to boot up the control plane as static Pods from directory \u0026#34;/etc/kubernetes/manifests\u0026#34;. This can take up to 4m0s [apiclient] All control plane components are healthy after 21.008446 seconds [upload-config] Storing the configuration used in ConfigMap \u0026#34;kubeadm-config\u0026#34; in the \u0026#34;kube-system\u0026#34; Namespace [kubelet] Creating a ConfigMap \u0026#34;kubelet-config\u0026#34; in namespace kube-system with the configuration for the kubelets in the cluster [upload-certs] Skipping phase. Please see --upload-certs [mark-control-plane] Marking the node panther-x2-main as control-plane by adding the labels: [node-role.kubernetes.io/control-plane node.kubernetes.io/exclude-from-external-load-balancers] [mark-control-plane] Marking the node panther-x2-main as control-plane by adding the taints [node-role.kubernetes.io/control-plane:NoSchedule] [bootstrap-token] Using token: fnxxr7.lgu8fvkl1rc0gukc [bootstrap-token] Configuring bootstrap tokens, cluster-info ConfigMap, RBAC Roles [bootstrap-token] Configured RBAC rules to allow Node Bootstrap tokens to get nodes [bootstrap-token] Configured RBAC rules to allow Node Bootstrap tokens to post CSRs in order for nodes to get long term certificate credentials [bootstrap-token] Configured RBAC rules to allow the csrapprover controller automatically approve CSRs from a Node Bootstrap Token [bootstrap-token] Configured RBAC rules to allow certificate rotation for all node client certificates in the cluster [bootstrap-token] Creating the \u0026#34;cluster-info\u0026#34; ConfigMap in the \u0026#34;kube-public\u0026#34; namespace [kubelet-finalize] Updating \u0026#34;/etc/kubernetes/kubelet.conf\u0026#34; to point to a rotatable kubelet client certificate and key [addons] Applied essential addon: CoreDNS [addons] Applied essential addon: kube-proxy Your Kubernetes control-plane has initialized successfully! To start using your cluster, you need to run the following as a regular user: mkdir -p $HOME/.kube sudo cp -i /etc/kubernetes/admin.conf $HOME/.kube/config sudo chown $(id -u):$(id -g) $HOME/.kube/config Alternatively, if you are the root user, you can run: export KUBECONFIG=/etc/kubernetes/admin.conf You should now deploy a pod network to the cluster. Run \u0026#34;kubectl apply -f [podnetwork].yaml\u0026#34; with one of the options listed at: https://kubernetes.io/docs/concepts/cluster-administration/addons/ Then you can join any number of worker nodes by running the following on each as root: kubeadm join 192.168.2.191:6443 --token fnxxr7.lgu8fvkl1******* \\ --discovery-token-ca-cert-hash sha256:17a1ad0ad3da3cd3d558c7ba9029cd0043c5a4fa53c2********************* 安装成功。已经提示需要再在Work节点使用 kubeadm join 就行了\n1 2 kubeadm join 192.168.2.191:6443 --token fnxxr7.lgu8fvkl1******* \\ --discovery-token-ca-cert-hash sha256:17a1ad0ad3da3cd3d558c7ba9029cd0043c5a4fa53c2********************* 安装Pod 网络附加组件 查看node 状态执行之前需要根据上面的提示让当前用户有管理k8s的权限：\n1 2 3 mkdir -p $HOME/.kube sudo cp -i /etc/kubernetes/admin.conf $HOME/.kube/config sudo chown $(id -u):$(id -g) $HOME/.kube/config 然后使用kubectl get nodes 查看每个node的状态，目前是notready的状态，需要安装网络覆盖组件\n首先，在您的集群上安装 Operator\n1 kubectl create -f https://raw.githubusercontent.com/projectcalico/calico/v3.26.0/manifests/tigera-operator.yaml 下载配置 Calico 所需的自定义资源\n1 curl https://raw.githubusercontent.com/projectcalico/calico/v3.26.0/manifests/custom-resources.yaml -O 创建清单以安装 Calico\n1 kubectl create -f custom-resources.yaml 稍等一会查看所有pod状态\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 root@panther-x2-main:~# kubectl get pod -A NAMESPACE NAME READY STATUS RESTARTS AGE calico-apiserver calico-apiserver-76fd8c9559-nfd8b 1/1 Running 0 3m6s calico-apiserver calico-apiserver-76fd8c9559-zbwrq 1/1 Running 0 3m6s calico-system calico-kube-controllers-6bcdfc4b44-mlp8w 1/1 Running 0 15m calico-system calico-node-7gv5s 1/1 Running 0 15m calico-system calico-node-ck8vf 1/1 Running 0 15m calico-system calico-node-scd9k 1/1 Running 0 15m calico-system calico-node-vzwr9 1/1 Running 0 15m calico-system calico-typha-5fd468897-gw7gd 1/1 Running 0 15m calico-system calico-typha-5fd468897-n2qkq 1/1 Running 0 15m calico-system csi-node-driver-9ph8d 2/2 Running 0 15m calico-system csi-node-driver-kj26d 2/2 Running 0 15m calico-system csi-node-driver-m6945 2/2 Running 0 15m calico-system csi-node-driver-sjxps 2/2 Running 0 15m kube-system coredns-7bdc4cb885-5krtc 1/1 Running 7 (99m ago) 47h kube-system coredns-7bdc4cb885-pbxc4 1/1 Running 7 (99m ago) 47h kube-system etcd-panther-x2-main 1/1 Running 9 (99m ago) 47h kube-system kube-apiserver-panther-x2-main 1/1 Running 9 (99m ago) 47h kube-system kube-controller-manager-panther-x2-main 1/1 Running 6 (99m ago) 10h kube-system kube-proxy-8jgfs 1/1 Running 5 (99m ago) 47h kube-system kube-proxy-9g4vg 1/1 Running 5 (99m ago) 47h kube-system kube-proxy-qc84s 1/1 Running 5 (99m ago) 47h kube-system kube-proxy-zwbqm 1/1 Running 9 (99m ago) 47h kube-system kube-scheduler-panther-x2-main 1/1 Running 9 (99m ago) 47h tigera-operator tigera-operator-58f95869d6-9ldmz 1/1 Running 0 16m 运到问题解决办法 查看某个pod 一直失败的状态需要查看日志:\n1 kubectl logs --namespace kube-system calico-node-2kdks 需要指定命令空间，最后才是pod 名称\n通过查看日志就知道是哪里出错了，我一开始是因为Docker 切换运行时的问题卡了很久,然后就是一步步地查看日志去搜索解决的。\n再如果是哪个pod一直卡住了，用kubectl create -f ***.yaml命令都删不掉需要执行手动强制删除pod命令：\n1 2 kubectl delete pod \u0026lt;podname\u0026gt; -n \u0026lt;namespace\u0026gt; kubectl delete pod metrics-server-7b4c4d4bfd-c2b7c -n kube-system 最后安装kubernetes/dashboard 直接打开官方GitHub 按照命令执行：\n1 kubectl apply -f https://raw.githubusercontent.com/kubernetes/dashboard/v2.7.0/aio/deploy/recommended.yaml 查看下是否完成了安装： 然后再根据官方文档使用 Kubernetes 的服务帐户机制创建新用户，授予该用户管理员权限并使用与该用户绑定的不记名令牌登录仪表板\n1 2 3 4 5 6 7 8 vim admin-user.yaml apiVersion: v1 kind: ServiceAccount metadata: name: admin-user namespace: kubernetes-dashboard 1 2 3 4 5 6 7 8 9 10 11 12 13 14 vim cluster-admin.yaml apiVersion: rbac.authorization.k8s.io/v1 kind: ClusterRoleBinding metadata: name: admin-user roleRef: apiGroup: rbac.authorization.k8s.io kind: ClusterRole name: cluster-admin subjects: - kind: ServiceAccount name: admin-user namespace: kubernetes-dashboard 然后再自己新建一个service 资源把dashboard的资源端口暴露出来：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 root@panther-x2-main:~/dashboard# cat dashbord-service.yaml kind: Service apiVersion: v1 metadata: labels: k8s-app: kubernetes-dashboard name: kubernetes-dashboard namespace: kubernetes-dashboard spec: type: NodePort ports: - port: 443 targetPort: 8443 nodePort: 30002 selector: k8s-app: kubernetes-dashboard 新建service资源：\n1 kubectl apply -f dashbord-service.yaml 依次创建它们：\n1 2 kubectl apply -f admin-user.yaml kubectl apply -f cluster-admin.yaml 获取不记名令牌:\n1 kubectl -n kubernetes-dashboard create token admin-user 得到token: 然后访问dashboard的内网地址和service 端口，填入刚生成的token记得要加https 进来了： 可以在这里里面创建新的资源： 教程到此完结\n","date":"2023-06-21T11:09:58+08:00","image":"https://munihehacker/my-blog.github.io/p/%E7%94%A8arm%E7%9B%92%E5%AD%90-%E5%86%8D%E6%AC%A1%E6%90%AD%E5%BB%BA%E4%B8%80%E4%B8%AA%E6%9C%80%E6%96%B0%E7%89%88%E6%9C%AC%E7%9A%84k8s%E9%9B%86%E7%BE%A4/1.27_hu5b229904d88bae7b6c258a13fba219d7_17319_120x120_fill_box_smart1_3.png","permalink":"https://munihehacker/my-blog.github.io/p/%E7%94%A8arm%E7%9B%92%E5%AD%90-%E5%86%8D%E6%AC%A1%E6%90%AD%E5%BB%BA%E4%B8%80%E4%B8%AA%E6%9C%80%E6%96%B0%E7%89%88%E6%9C%AC%E7%9A%84k8s%E9%9B%86%E7%BE%A4/","title":"用ARM盒子 再次搭建一个最新版本的K8s集群"},{"content":"《蛤蟆先生去看心理医生》 《蛤蟆先生去看心理医生》是中国作家刘震云所著的小说，出版于1985年。这本小说以一个荒诞的故事情节为背景，揭示了人性的复杂和社会的丑陋。\n故事主要讲述了一个叫做蛤蟆先生的人，在某个晚上突然发现自己变成了一只大蛤蟆。在接下来的日子里，他试图寻找治疗方法，最终前往看心理医生。在与心理医生的交流中，蛤蟆先生逐渐认识到了自己内心深处的不安和焦虑，并最终通过心理治疗得以重获新生。\n小说以荒谬的情节与幽默的语言展示了我们身处的社会和我们自己的内心，对当时的社会现实进行了批判。通过蛤蟆先生的经历，作者揭示了我们现代人追求物质利益和名利的一面，同时也表达了对于精神层面的关注和抚慰的期望。\n总之，《蛤蟆先生去看心理医生》是一部思想深刻、颇具启发性的小说，它通过一个寓言式的故事情节，反映了社会和人类内心深处的各种问题，是一部值得一读的好书。\n","date":"2023-05-18T10:35:13+08:00","image":"https://munihehacker/my-blog.github.io/p/%E4%B9%A6%E7%B1%8D%E6%94%B6%E9%9B%86/title_hu33279d7a90344b982fdb1ea5b532fca9_482234_120x120_fill_box_smart1_3.png","permalink":"https://munihehacker/my-blog.github.io/p/%E4%B9%A6%E7%B1%8D%E6%94%B6%E9%9B%86/","title":"书籍收集"},{"content":"前言 看到张大妈网站有一个非常火的文章，分享如何使用docker 部署一个24小时直播推流的服务薅羊毛，正好有闲置的服务器，然后每天收益大概有1元钱，于是就想试一下。\n项目介绍 项目地址：bytelang/kplayer-go\n项目介绍看图 部署 第一步准备docker 镜像\n1 docker pull bytelang/kplayer:latest 准备配置文件路径映射 准备工作，准备三个文件/文件夹映射\n1.配置文件映射\n2.播放资源的文件夹映射\n3.缓存目录的映射\n我的服务器是Linux Centos系统，服务器叫宿主机。\n宿主机文件地址是需要自己自定义的\n宿主机播放资源文件地址(放了一些抖音视频)：/home/***/mp4 宿主机配置文件（稍后再说）：/home/***/kplayer/config.json 宿主机直播编码缓存文件地址 ：/home/***/kplayer/cache 容器映射的文件目录是固定的\n宿主机播放资源文件地址是根据config.json内容配置文件来定义的\n容器播放资源文件地址：/video 宿主机配置文件（必须固定的地址）：/kplayer/config.json 容器播放资源文件地址（必须固定的地址）：/kplayer/cache 获取BiliBili 直播推流地址 1.首页直播：\n2.网页右侧开播设置：\n3.选择分类，点击开播，前提是需要身份证和姓名实名认证：\n4.得到直播推流地址：\n服务器地址 拼接上 串流密钥 就是推流的地址： rtmp://live-push.bilivideo.com/live-bvc/?streamname=live_******_******\u0026amp;key=**************\u0026amp;schedule=rtmp\u0026amp;pflag=1\nconfig.json配置文件内容 在宿主机/home/***/kplayer/config.json内容如下（把上面获取的推流地址替换到下面的配置文件中） ：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 { \u0026#34;version\u0026#34;: \u0026#34;2.0.0\u0026#34;, \u0026#34;resource\u0026#34;: { \u0026#34;lists\u0026#34;: [ \u0026#34;/video/\u0026#34; ], \u0026#34;extensions\u0026#34;: [\u0026#34;mp4\u0026#34;] }, \u0026#34;output\u0026#34;: { \u0026#34;lists\u0026#34;: [ { \u0026#34;path\u0026#34;: \u0026#34;rtmp://live-push.bilivideo.com/live-bvc/?streamname=live_******_******\u0026amp;key=**************\u0026amp;schedule=rtmp\u0026amp;pflag=1\u0026#34; } ], \u0026#34;reconnect_internal\u0026#34;: 5 }, \u0026#34;play\u0026#34;: { \u0026#34;fill_strategy\u0026#34;: \u0026#34;ratio\u0026#34;, \u0026#34;skip_invalid_resource\u0026#34;: true, \u0026#34;cache_on\u0026#34;: true, \u0026#34;play_model\u0026#34;: \u0026#34;random\u0026#34;, } } 注意 ['resource']['lists'] 的配置内容就是 容器内的播放资源文件地址\n\u0026quot;cache_on\u0026quot;:true 就是启用推流编码缓存，会生成缓存，命中缓存节约CPU资源\n\u0026quot;play_model\u0026quot;: \u0026quot;random\u0026quot; 就是在播放列表中随机播放\n启动运行 使用docker 运行容器 加上上面的文件目录映射就可以了：\n1 docker run -td --name=kplayer -v /home/***/mp4:/video -v /home/***/kplayer/config.json:/kplayer/config.json -v /home/***/kplayer/cache:/kplayer/cache --restart=always bytelang/kplayer:latest 使用docker logs kplayer查看日志，看到下面的日志就表示成功了： 访问直播地址也正常直播了。\n","date":"2023-03-02T20:54:10+08:00","image":"https://munihehacker/my-blog.github.io/p/kplayer-24%E5%B0%8F%E6%97%B6bilibili%E7%9B%B4%E6%92%AD%E6%8E%A8%E6%B5%81-docker%E9%83%A8%E7%BD%B2%E6%95%99%E7%A8%8B/2023-3-2-1677761236933_hu8347a51a7486d2e04b0e38ca20b0b231_13293_120x120_fill_box_smart1_3.png","permalink":"https://munihehacker/my-blog.github.io/p/kplayer-24%E5%B0%8F%E6%97%B6bilibili%E7%9B%B4%E6%92%AD%E6%8E%A8%E6%B5%81-docker%E9%83%A8%E7%BD%B2%E6%95%99%E7%A8%8B/","title":"Kplayer 24小时BiliBili直播推流 docker部署教程"},{"content":"Mysql 版本 目前都是使用的8.0，了解一下8.0对于之前的旧版本的新特性\n8.0版本默认字符集将由 latin1 改为 utf8mb4\n参考链接：The MySQL 8.0.0 Milestone Release is available\n储存引擎 MySQL 5.5 版本之后开始采用 InnoDB 为默认存储引擎，之前版本默认的存储引擎为 MyISAM\n存储引擎操作的对象是表，存储引擎的功能是接收上层传下来的指令，然后对表中的数据进行读取或写入的操作\n区别：\nInnoDB 支持事务，MyISAM 不支持（InnoDB每个语句就是一个事务）\nInnoDB支持表级锁、行级锁，默认为行级锁；而 MyISAM 仅支持表级\nInnoDB 必须要有主键，MyISAM可以没有主键（InnoDB不建索引的话会隐藏的生成一个 6 byte 的 int 型的索引作为主键索引。）\nInnoDB是聚集索引，MyISAM是非聚集索引（索引和数据文件是分离）（聚集索引查询数据速度快，使用较少的内存）\n查询语句生命周期 1.sql通过网络通信协议，从客户端发磅到服务端。\n2.服务端收到sql后，查询缓存是否有匹配结果，若存在缓存，则直接取出缓存中结果返回，\n否则进行下一阶段。\n3.服务端对sql进行解析、预处理，然后生成查询计划。\n4.执行引擎根据优化器生成的查询计划，调用存储引擎的API接口，拿到查询结果，然后返回\n给客户端，同是缓存查询结果，不过缓存查询结果需要手动配置才会生效。\n常用的数据类型 提前了解字符集 Mysql常见字符集：\nutf8mb4 utf8字符集，使用1～4个字节表示字符。mb4就是most bytes 4的意思，专门用来兼容四字节的unicode，utf8mb4是utf8的超集,兼容性比价好，可能会耗费更多的存储空间 1 2 3 4 5 6 CREATE TABLE `user` ( `id` int unsigned NOT NULL AUTO_INCREMENT COMMENT \u0026#39;主键\u0026#39;, `name` varchar(10) CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci NOT NULL COMMENT \u0026#39;姓名\u0026#39;, ... UNIQUE KEY `id_card` (`id_card`) USING BTREE ) ENGINE=InnoDB AUTO_INCREMENT=147492 DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci; utf8 1～3字节\nutf8mb3 等价于 utf8\n中文是占 3 个字节，其他数字、英文、符号占一个字节。emoji 符号占 4 个字节，一些较复杂的文字、繁体字也是 4 个字节\nnavicate 新建数据库需要置顶字符集和排序规则：\n如果创建数据库时没有显式的指定字符集和比较规则，则该数据库默认用服务器的字符集和比较规则\n测试服库默认字符集和排序规则：\nutf8mb4\nutf8mb4_0900_ai_ci\n常见排序规则 utf8mb4_unicode_ci ，utf8mb4_general_ci\n常见字符集： utf8mb4，utf8\n需要统一，建库的时候统一字符集和排序规则\n如果创建表时没有显式的指定字符集和比较规则，则该表默认用数据库的字符集和比较规则\n比较规则的作用通常体现比较字符串大小的表达式以及对某个字符串列进行排序中\n回顾一下计算机储存单位：\n1个bit 只能存 0或者1\n8位(bit)=1字节(Byte)\n1024字节=1KB\nint\n整数值，支持2147483648～2147483647（如果是UNSIGNED，\n为0～4294967295）的数\ntinyint\n整数值， 128～127（如果为UNSIGNED，为0～255）的数值\nchar\n1～255个字符的定长串。它的长度必须在创建时指定，否则MySQL\n假定为CHAR(1)\nvarchar\n长度可变，最多不超过255字符数。如果在创建时指定为VARCHAR(n)，\n则可存储0到n个字符的变长串（其中n≤255）\nutf-8 编码 中1个汉字1个字母 就是占用1个字符数（实测）\ntext\n最大长度为64 K的变长文本 指针类型\nDATE\n表示1000-01-01～9999-12-31的日期，格式为\nYYYY-MM-DD\nTIME\n格式为HH:MM:SS\ndatetime\nDATE和TIME的组合\nENUM\n接受最多64 K个串组成的一个预定义集合的某个串\ndecimal\n精度可变的浮点值\nvarchar 和text 小数据量的查询和插入几乎性能一样\n索引，索引类型，特点 B+树\n最左 匹配原则\n联合索引\n联合索引有哪些好处？\n(1) 减少开销。\n建一个联合索引(tcol01, tcol02, tcol03)，相当于建立三个索引(tcol01)、(tcol01, tcol02)、(tcol01, tcol02, tcol03)的功能。每个索引都会占用写入开销和磁盘开销，对于大量数据的表，使用联合索引会大大的减少开销。\n(2) 覆盖索引。\n对联合索引(tcol01, tcol02, tcol03)，如果有如下的SQL，\n(3) 效率高。\n多列条件的查询下，索引列越多，通过索引筛选出的数据就越少。\n锁，事务 事务功能就是让数据库操作符合现实世界中状态转换的规则,特性\n原子性\n隔离性\n一致性\n持久性\n探索： 主从，日志，备份，迁移，恢复，分库分表\n讨论\u0026amp;优化方案 禁止建立预留字段？这种在那个情况有没有用呢？\n冷热数据分离，不会经常读取的数据拎出来？\n代码中一些问题，尽量避免地一些问题，归纳总结\n1.储存相同数据的列名和列类型必须一致\n2.尽量减少 select *\n3.尽量用数值代替字符串类型，字符串需要逐个对比每一个字符，数值只需要比较一次。增加储存开销和查询性能\n4.varchar 代替char ,\n5.避免使用EMUN 枚举类型，order by 效率低。\n6.where 避免使用null ，也就是设计字段时默认值避免使用null ，is null ，is not null 优化器会放弃查询索引，使用null 查询也不直观\n7.避免使用where != ,where \u0026lt;\u0026gt; 很可能会让索引时生效\n8.优先使用inner join ，只保留两表完全匹配的结果集。\n9.避免长事务，会进行加锁，影响相关业务\n10.联合索引长度小的列放在左侧，最左特性\n11.控制表的数据量，修改表结构，加索引，备份，恢复会出现问题\n归档方案，分库分表\n12.所有的表和字段都要有注释，\n13.大表经常查询要确认好索引，可以拿出来讨论啊，排序，主要where 条件加索引\n14.修改删除重要数据，要先备份\n15.尽量把列的默认值定义为not NULL\n16.伪删除设计？\n17.索引不适合建立在大量重复的数据的字段上，例如性别，月份，不适合\n参考： MySQL 是怎样运行的：从根儿上理解 MySQL\nMySQL 性能调优必知必会\n《高性能MySQL 第3版》\n《MySQL必知必会》\n","date":"2023-02-24T10:23:44+08:00","permalink":"https://munihehacker/my-blog.github.io/p/mysql-psot/","title":"Mysql Psot"},{"content":"0.困境 1 问题 完成任务都需要一定的时间，同时，任何任务都最好或者必须在某个特定的时间点之前完成，不管是否已经开始执行，最后期限都在不断的迫近，因为时间永不停歇\n2 慌乱 “没时间了“，其可怕程度几乎无异于死亡。死亡本身并不可怕，面临死亡的过程才真正可怕。\n3 解决 我们无法管理时间，我们真正能够管理的，是我们自己，人很难接受与已有知识和经验相悖的信息或观念。问题出现在我们自己身上，解决问题的核心思想只有一个：一切都靠积累。深信积累的力量，时间就是你的朋友，否则，它就是你的敌人。\n一.醒悟 1 谁是大脑的主人 我们竟然可以用自己的大脑控制自己的大脑~，做自己的主宰者，需要经过长期的思考，意识自己可以控制自己的大脑，不再让自己“跟着感觉走”，成为大脑的奴隶，而是翻身做大脑的主人。\n人所有的任何东西都可以被剥夺，唯独人性最后的自由---也就是在任何境遇中选择一己态度和生活方式的自由---不能被剥夺。\n需要心智获得解放\n2 何谓心智 一个人的心智就是其过往获得的一切知识及经验的总和，心智一旦开启，就会不断自我积累，自我过滤，直至根深蒂固，人与人之间心智力量的差异，就是这样积累，最终天差地别。\n心智这东西“上不封顶，下午保底“\n3 案例 有些认知，哪怕只是最简单的常识也需要亲身经历后才能真正体会，有的人经过了一些事情能自然而然地理解并相信”技多不压身“的道理。有的人会觉得”没学也没什么“,”不知道学它有很没用“,”现在学也来不及了“,或者后面感概”当初不懂事，要是学过就好了“。\n拒绝学习和接受学习都会慢慢融入心智，和过去一样做出同样的选择\n二.现实 1 速成绝无可能 人人都想速成，”有些阶段是无法跨越的“。\n越是浮躁，就越是对自己的现状不满；越是对自己的现状不满，就越是浮躁\n一方面是自己的欲望无线，一方面是要完成的事情太多了，一方面是自我满意度的不断下降\u0026ndash;这就是人们总是不由自主的去期望速成的根源。出路肯定存在，但这出路只有一个起点\u0026ndash;接受现实。告诉自己有不足，我需要时间，我没办法一蹴而就。\n2 交换才是硬道理 想办法跳出恶性循环，我要什么我有什么，不要让欲望之火烧自己的时间和精力，”我要“的欲望从来不会消减，需要借助已经拥有的足够的努力和勤奋，花上一点时间换取自己想要的，不仅”我有“的更多，”我要“的也更容易获得。\n3 完美永远不存在 ","date":"2023-02-03T21:33:13+08:00","image":"https://munihehacker/my-blog.github.io/p/%E6%8A%8A%E6%97%B6%E9%97%B4%E5%BD%93%E4%BD%9C%E6%9C%8B%E5%8F%8B/img_5_hu2d3d99e2fcb826ebb443e910cad5a781_142739_120x120_fill_box_smart1_3.png","permalink":"https://munihehacker/my-blog.github.io/p/%E6%8A%8A%E6%97%B6%E9%97%B4%E5%BD%93%E4%BD%9C%E6%9C%8B%E5%8F%8B/","title":"《把时间当作朋友》"},{"content":"前篇文章记录了斐讯N1怎么安装frpc内网穿透，现在来继续折腾Alist插件,把本地存储和网盘集中到自己的搭建的Web服务中。\n主要是看中了Alist颜值高和网盘挂载的功能。\n使用Docker 安装 Alist N1盒子已经自带了Docker软件，接下来直接使用Docker安装Alist，注意映射的本地目录。\n我自己想让Alist管理的本地文件夹是N1盒子插的一块硬盘特定的文件夹\n文件目录为：/sharedfolders/N1/alist\n官方的教程是把容器里面的alist运行配置映射到宿主机（alist容器内的配置文件路径：/opt/alist/data）\n我再添加一个目录映射专门把宿主机的文件映射到Alist容器内部，让Alist管理\n1 docker run -d --restart=always -v /sharedfolders/N1/alist/config:/opt/alist/data -v /sharedfolders/N1/alist/data:/home -p 5244:5244 --name=\u0026#34;alist\u0026#34; xhofe/alist:latest 然后在命令行运行docker exec -it alist ./alist -password查看初始密码：\n访问内网地址192.168.2.122:5244进入alist的管理界面：\n一进来就会提示没有挂载，此时不着急，点击下方登录，使用上面的密码登录，用户名是：admin\n登录进入改下密码，然后设置储存：\n添加本机存储：\n挂载/home目录 ，根文件夹路径也是/home：\n点击添加就可以了。再访问192.168.2.122:5244\n就看到挂载的本机存储了：\n到现在基础功能就实现了\n尝试挂载网盘 挂载天翼云盘尝试一下，相对比较简单\n在管理-\u0026gt;储存-\u0026gt;添加：\n挂载路径就是在访问Alist的时候此时添加的储存的名字\n用户名就是天翼云的账号也就是手机号。密码也就是天翼云盘的登录密码\n根文件夹ID就是在访问web端的天翼云盘的文件夹ID, -11就是网盘的根目录：\n最后效果\u0026amp;设置密码 接下来尝试可以给特定的文件夹添加密码\n在 在管理-\u0026gt;元信息-\u0026gt;添加：\n设置目录和密码就可以了，推出登陆后访问这个文件夹就会提示输入密码：\n输入密码后还可以展示刚刚设置的文件夹说明：\n后面我会把这这个Alist通过内网穿透使它能够在公网访问，然后尝试使用webdav挂载网盘到Windows，把网盘当作系统硬盘来使用\n","date":"2023-02-02T21:20:24+08:00","image":"https://munihehacker/my-blog.github.io/p/%E8%AE%B0%E5%BD%95%E4%B8%80%E6%AC%A1%E4%BD%BF%E7%94%A8docker-%E5%AE%89%E8%A3%85alist%E6%8F%92%E4%BB%B6-%E6%8C%82%E8%BD%BD%E6%9C%AC%E5%9C%B0%E5%AD%98%E5%82%A8%E5%92%8C%E7%BD%91%E7%9B%98/img_14_hu9e44a443e7bb9a636994c9b29628a2be_48043_120x120_fill_box_smart1_3.png","permalink":"https://munihehacker/my-blog.github.io/p/%E8%AE%B0%E5%BD%95%E4%B8%80%E6%AC%A1%E4%BD%BF%E7%94%A8docker-%E5%AE%89%E8%A3%85alist%E6%8F%92%E4%BB%B6-%E6%8C%82%E8%BD%BD%E6%9C%AC%E5%9C%B0%E5%AD%98%E5%82%A8%E5%92%8C%E7%BD%91%E7%9B%98/","title":"记录一次使用docker 安装Alist插件 挂载本地存储和网盘"},{"content":"记录一次frp客户端安装\n最近是把老路由器换下来了，之前的使用的是路由器挂硬盘当Nas，换了新路由器没有USB接口，把之前的电视盒子斐讯N1拿出来了，刷了一个FastNas系统 ，但是没有Frp内网穿透功能，只有自己安装。\n下载解压 frp项目地址：https://github.com/fatedier/frp 找到自己跟自己frp服务端匹配的版本 ，再确认N1的系统版本\n下载对应的客户端：\n1 wget https://github.com/fatedier/frp/releases/download/v0.34.2/frp_0.34.2_linux_arm64.tar.gz 解压tar.gz文件命令：\n1 tar -zxvf frp_0.34.2_linux_arm64.tar.gz cd 进入到解压后的文件夹找到客户端需要用的文件分别为：frpc.ini 和 frpc\n首先编辑frpc.ini配置文件连接服务端\n1 2 3 4 5 6 7 8 9 [common] server_addr = ***.***.***.*** server_port = 7000 token = ***** [ssh] type = tcp local_ip = 127.0.0.1 local_port = 22 remote_port = 37051 连接服务端只需要3个配置 ，地址，端口，密钥\n[ssh]是frp客户端需要穿透出去的服务 web服务是http服务的，基于tcp的可靠协议\nlocal_ip本地服务地址\nlocal_port本地服务的端口\nremote_port穿透映射到公网服务器的端口\n然后把frpc.ini 和 frpc两个文件移动到自己设置的位置，尽量不要放到解压出来的文件夹，不然过了一段时间就会忘记会把它误删掉。\n我把它们分别移动到了/usr/local/frp/frpc 和 /etc/frp/frpc.ini位置\n然后使用系统自带的 sytemctl 服务管理功能 启动frpc服务并且开机自启\n找到 sytemctl 配置文件夹 /lib/systemd/system 新建 frpc.service 文件输入一下内容：\n1 2 3 4 5 6 7 8 9 10 11 12 13 [Unit] Description=frpc Wants=network-online.target After=network.target network-online.target Requires=network-online.target [Service] ExecStart=/usr/local/frp/frpc -c /etc/frp/frpc.ini ExecStop=/bin/kill $MAINPID Restart=always RestartSec=5 StartLimitInterval=0 [Install] WantedBy=multi-user.target 然后执行systemctl start frpc 启动frpc服务 然后使用systemctl status frpc 查看服务状态: 最后执行systemctl enable frpc 设置开机自启\n最后测试 使用公网IP，在frpc客户端配置的remote_port连接： ","date":"2023-02-01T21:02:54+08:00","image":"https://munihehacker/my-blog.github.io/p/%E8%AE%B0%E5%BD%95%E4%B8%80%E6%AC%A1frp%E5%AE%A2%E6%88%B7%E7%AB%AF%E5%AE%89%E8%A3%85/title_hu775b17d495e6819cdc3bca27d89ad894_27323_120x120_fill_box_smart1_3.png","permalink":"https://munihehacker/my-blog.github.io/p/%E8%AE%B0%E5%BD%95%E4%B8%80%E6%AC%A1frp%E5%AE%A2%E6%88%B7%E7%AB%AF%E5%AE%89%E8%A3%85/","title":"记录一次frp客户端安装"},{"content":"composer相当于PHP 包管理器,在日常工作中有很多可以复用的代码都可以制作私有composer包来进行分发，统一管理，特别是在公司内部一些新项目初始化需要使用一些公共的方法就不需要重复复制了，可以减少很多心智负担，使用composer命令就能下载项目的依赖包。\n前提 安装composer 安装Git\n公网IP机器，域名解析，Docker\n制作composer包 先找到一个空目录，执行composer 初始化命令：\n1 composer init 然后出现一连串的询问：\n1.This command will guide you through creating your composer.json config.` Package name (/) :\n填写自己的包名,我填写的是：koala9527/composer-build\n2.Description []:\n需要填写这个包的描述信息，我填写的是：just test\n3.Author [**** koala9217@qq.com, n to skip]:\n提示填写作者信息，可以直接跳过输入n\n4.Minimum Stability []:\n提示填写最小稳定版本，可输入内容为：stable, RC, beta, alpha, dev，稳定性依次从左到右从大到小，越左边越稳定bug越少，自己测试的包就输入：dev\n5.Package Type (e.g. library, project, metapackage, composer-plugin)[]: library\n提示填写项目类型\nlibrary: 这是默认类型，它会简单地将文件复制到 vendor 目录。 project: 这表示当前包是一个项目，而不是一个库。 metapackage: 当一个空的包，包含依赖并且需要触发依赖的安装，这将不会对系统写入额外的文件。因此这种安装类型并不需要一个 dist 或 source。 composer-plugin: 一个安装类型为 composer-plugin 的包，它有一个自定义安装类型，可以为其它包提供一个 installler。\n这里就是填的默认类型\n6.License[]: 提示填写开源许可证 参考下图： 填写一个最宽松的MIT许可\n7.Would you like to define your dependencies (require) interactively [yes]？\n提示是否需要设置依赖环境或者其他包，输入yes\n8.Search for a package：\n提示搜索哪个依赖?依赖PHP,输入php\n9.Enter the version constraint to require (or leave blank to use the latest version)：\n需要哪个版本？注意最好是精确输入自己电脑环境一样的PHP版本，我这里是7.4.30，不然会出现以下报错： 10.重复询问7和8的问题，直接回车跳过\n11.Add PSR-4 autoload mapping? laps namespace \u0026ldquo;Koala9527\\Composerbuild\u0026quot;to the entered relative path. [src/, n to skip]:\n是否添加PSR-4自动加载映射，将命名空间 “Koala9527\\Composerbuild “映射到输入的相对路径， 这里输入了n 跳过，在后面composer.json自己增加autolaod的配置\n接下来就会预览这个composer包composer.json的预览内容,下面会再次询问是否确认生成\n11.Do you confirm generation[yes]?\n确认生成 yes\nWould you like to install dependencies now [yes]? 是否先择安装依赖，输入yes ,没有其他依赖会直接完成\n最后整个过程截图： 生成的文件目录结构：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 |-- composer-build\u0026#39;, |-- composer.json\u0026#39;, |-- composer.lock\u0026#39;, |-- package-lock.json\u0026#39;, |-- vendor\u0026#39;, |-- autoload.php\u0026#39;, |-- composer\u0026#39;, |-- autoload_classmap.php\u0026#39;, |-- autoload_namespaces.php\u0026#39;, |-- autoload_psr4.php\u0026#39;, |-- autoload_real.php\u0026#39;, |-- autoload_static.php\u0026#39;, |-- ClassLoader.php\u0026#39;, |-- installed.json\u0026#39;, |-- installed.php\u0026#39;, |-- InstalledVersions.php\u0026#39;, |-- LICENSE\u0026#39;, |-- platform_check.php\u0026#39;, 此时这个composer包没有任何内容，我们需要给他添加一个测试的功能代码\n新建功能代码之前需要在composer.json添加pst-4自动加载配置，在项目根目录composer.json添加以下代码：\n1 2 3 4 5 \u0026#34;autoload\u0026#34;: { \u0026#34;psr-4\u0026#34;: { \u0026#34;Test\\\\\u0026#34;: \u0026#34;src/\u0026#34; } } 然后在项目根目录新建src 目录，在src目录下Test.php文件，文件内容为：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 \u0026lt;?php namespace Test; class Test { public function index() { echo \u0026#39;composer包测试成功\u0026#39;; } } 然后执行 composer dump-autoload命令 自动加载类映射 生成配置，具体配置内容在vendor/composer/autoload_psr4.php 文件中\n最后在根目录下新建一个index.php文件测试，内容为：\n1 2 3 4 5 \u0026lt;?php require \u0026#34;vendor/autoload.php\u0026#34;; use Test\\Test; $Test = new Test(); $Test-\u0026gt;index(); 使用PHP 命令运行这个index.php 文件：\n测试成功！\n上传GitHub 项目需要公开，首先新建一个Git仓库 把刚刚制作的composer 项目全部代码上传\n依次执行以下Git命令就上传成功了\n1 2 3 4 5 6 git init git add . git commit -m \u0026#39;first commit\u0026#39; git branch -M main git remote add origin git@github.com:koala9527/composer-test.git git push -u origin main 搭建satis仓库 satis是Composer 官方提供的建立私有源的工具，比较简单，原理就是把Git仓库里的composer 包拉取下来制作成静态文件，然后需要自己通过Nginx镜像容器部署形成一个简单的UI界面，进行composer包的分发下载的服务\n这里只做一个最简单的尝试，没有权限验证的配置\n首先是需要一个公网的机器\n选定一个空白文件夹新建一个satis.json配置文件。内容如下(/home/satis/build/satis.json)：\n1 2 3 4 5 6 7 8 { \u0026#34;name\u0026#34;: \u0026#34;koala/composer-test\u0026#34;, \u0026#34;homepage\u0026#34;: \u0026#34;http://satis.tuwei.space\u0026#34;, \u0026#34;repositories\u0026#34;: [ {\u0026#34;type\u0026#34;: \u0026#34;vcs\u0026#34;, \u0026#34;url\u0026#34;: \u0026#34;https://github.com/koala9527/composer-test\u0026#34; } ], \u0026#34;require-all\u0026#34;: true } 注意：\njson配置文件中name字段必须是在composer包创建时的vendor/package的内容，否则无法初始化\nhomepage 是satis仓库的访问域名地址，也就是自己私有源的地址\nrepositories就是配置自己的GitHub项目地址，这里可以配置成一个列表，包含多个composer包。vcs的意思是版本控制系统\nrequire-all 拉取全部包\n使用composer/satis 镜像拉取GitHub内容打包静态文件和UI界面：\n1 docker run --rm -it -v /home/satis/build:/build -v /home/satis/composer:/composer composer/satis 主要参数是--rm ，容器只运行一次，退出时删除。\n在宿主机/home/satis/build目录下会生成output 文件夹，此时把这个文件通过Nginx容器运行起来，然后通过域名解析，satis私有仓库就搭建完成了 通过Nginx镜像运行静态UI界面\n1 docker run -itd --name=nginx_satis -p 8881:80 -v /home/satis/build/output:/usr/share/nginx/html nginx 域名解析到宿主机8881端口，这里通过自己服务中的宝塔反向代理解析，现在访问域名：\nsatis.tuwei.space\n测试 拿一个不重要的Hyperf项目测试，项目根目录下composer.json文件添加私有源配置：\n1 2 3 4 5 6 \u0026#34;repositories\u0026#34;: [ { \u0026#34;type\u0026#34;: \u0026#34;composer\u0026#34;, \u0026#34;url\u0026#34;: \u0026#34;http://satis.tuwei.space\u0026#34; } ] 还可以更换全局的composer 源来拉取这个私有composer包：\n1 composer config -g repo.packagist composer http://satis.tuwei.space 自己的私有仓库是http协议，需要取消安全检查，不然在composer require 命令会报错：\n1 composer config -g secure-http false 使用composer require 拉取私有包：\n1 composer require koala/composer-test 参考教程 https://hub.docker.com/r/composer/satis\nhttps://zhuanlan.zhihu.com/p/542952527\n","date":"2023-01-30T11:55:51+08:00","image":"https://munihehacker/my-blog.github.io/p/%E5%88%B6%E4%BD%9C%E8%87%AA%E5%B7%B1%E7%9A%84composer%E5%8C%85%E6%90%AD%E5%BB%BAsatis%E7%A7%81%E6%9C%89%E4%BB%93%E5%BA%93/composer-title_hua21e3f3efb33c245031eecda590d33be_43130_120x120_fill_q75_box_smart1.jpg","permalink":"https://munihehacker/my-blog.github.io/p/%E5%88%B6%E4%BD%9C%E8%87%AA%E5%B7%B1%E7%9A%84composer%E5%8C%85%E6%90%AD%E5%BB%BAsatis%E7%A7%81%E6%9C%89%E4%BB%93%E5%BA%93/","title":"制作自己的composer包，搭建satis私有仓库"},{"content":"为什么要写博客 2022年结束，写了一篇年终报告，回顾发现记录总结是一个非常重要的事情，在接下来的时间需要把这件事养成一个习惯，不断记录，思考，积累 进步。\n选择Hugo Hugo 比较偏向后端，编译速度非常快，就这么简单。\n简单记录一下过程 首要任务是选择一个简单好看的主题：hugo-theme-stack\n这个主题最初是在V2EX 看到的，挺小清新的，符合现代审美。然后在Hugo的官方主题商店看到了它。\n看起来主题的亮色模式有点太白了，有些文字看得不是很清楚，后面再想办法调整一下。\n一开始看Hugo官方文档使用命令行新建一个Hugo项目再添加这个主题，因为有一些设置覆盖，一直没弄好，后面参考文档直接使用了这个主题的快速入门模板项目， 直接拉下来，调整配置直接运行起来了，目前使用项目自带的GitHub Action地配置搭配了一个二级域名部署在了GitHub Page上了。\n接下来仔细说说自己做了那些事，改了哪些东西。因为没有参考任何的教程，查找地相关教程都比较笼统，没有针对这个主题的教程，所以下面的内容全都是自己折腾实验的。\n改配置 快速启动模板的GitHub 地址：\nCaiJimmy/hugo-theme-stack-starter\ngit clone https://github.com/CaiJimmy/hugo-theme-stack-starter\n先把代码拉下来，所有的配置文件都在/config/_default 文件夹内，配置文件有很多，自己修改了其中个别几个，下面详细讲讲。\nconfig.toml 博客的基本信息\n标题，用户名，部署的域名，语言\n1 2 3 4 5 6 7 8 9 10 11 baseurl = \u0026#34;https://blog.tuwei.space\u0026#34; languageCode = \u0026#34;zh-Hans\u0026#34; paginate = 5 title = \u0026#34;koala9527的博客\u0026#34; DefaultContentLanguage = \u0026#34;zh-cn\u0026#34; hasCJKLanguage = false # Change it to your Disqus shortname before using disqusShortname = \u0026#34;koala9527\u0026#34; menu.toml 博客菜单\n删掉了Twitter联系方式，更改GitHub地址，没有什么拿得出手的，就留这个吧。\n1 2 3 4 5 6 7 [[social]] identifier = \u0026#34;github\u0026#34; name = \u0026#34;GitHub\u0026#34; url = \u0026#34;https://github.com/koala9527\u0026#34; [social.params] icon = \u0026#34;brand-github\u0026#34; params.toml 杂项，很多配置，没有仔细研究\n我只改了两项，个性签名和头像。\n1 2 3 4 5 6 7 8 [sidebar] emoji = \u0026#34;🍥\u0026#34; subtitle = \u0026#34;悟已往之不谏,知来者知可追\u0026#34; [sidebar.avatar] enabled = true local = true src = \u0026#34;img/avatar.jpg\u0026#34; 这里需要注意的是头像的文件位置，需要在项目根目录新建一个assets/img文件夹，把头像的图片文件放进去，官方文档是这么说的： 部署 先要在GitHub 新建一个公开的项目，我的自己项目地址： koala9527/my-hugo-blog\n此时需要注意推送的分支需要和快速启动模板内.github/deploy.yml文件的CI触发的分支一致。\n我一开始没看见注意使用的是main这个名字，项目中的出发分支名称是master无法触发自动部署。\n接着把本地修改的内容全部提交到刚刚新建的Github仓库，注意分支，Git仓库会触发Github Action自动新建一个gh-page的分支。\n解析域名 点击项目的Settings-\u0026gt;pages\n设置部署构建来源设置成来自分支\n分支名称为gh-pages\n然后再设置一个自定义域名\n设置域名过后需要在域名DNS服务商设置DNS解析。\n上面是是Git账号的域名解析，不确定是不是必须的，在账号设置下的page菜单中添加，添加过后会提示需要一个TXT类型域名解析用来 验证域名的所有权。 下面是项目的自定义域名解析，是一个二级域名，二级域名记录为blog，解析内容为koala9527.github.io ,记录类型为CNAME,koala9527为我自己的Github名称。 到此为止，整个博客的从零开始到上线部署就完成了。\n写在最后 GitHub的访问貌似有一点慢，后面考虑部署到CDN上面吧，静态页面博客部署，访问，迁移非常地方便快速，这些优点就非常明显！\n","date":"2023-01-07T20:33:43+08:00","image":"https://munihehacker/my-blog.github.io/p/%E8%AE%B0%E5%BD%95%E6%90%AD%E5%BB%BAhugo-%E5%8D%9A%E5%AE%A2%E4%BD%BF%E7%94%A8stack%E4%B8%BB%E9%A2%98%E5%BF%AB%E9%80%9F%E5%90%AF%E5%8A%A8%E9%83%A8%E7%BD%B2/stack_hu2fcf86eed2264053012faaf0a9c52a98_99085_120x120_fill_box_smart1_3.png","permalink":"https://munihehacker/my-blog.github.io/p/%E8%AE%B0%E5%BD%95%E6%90%AD%E5%BB%BAhugo-%E5%8D%9A%E5%AE%A2%E4%BD%BF%E7%94%A8stack%E4%B8%BB%E9%A2%98%E5%BF%AB%E9%80%9F%E5%90%AF%E5%8A%A8%E9%83%A8%E7%BD%B2/","title":"记录搭建Hugo 博客，使用stack主题快速启动部署"}]